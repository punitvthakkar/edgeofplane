<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Cursed Traveler's Journey</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Mali:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            font-family: 'Quicksand', 'Mali', sans-serif;
        
        #orientation-message {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            text-align: center;
            padding-top: 40vh;
            z-index: 1000;
            font-size: 24px;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            box-shadow: 0 0 30px rgba(120, 180, 240, 0.3);
        }

        @media (orientation: portrait) and (max-width: 768px) {
            #orientation-message {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="orientation-message">
        Please rotate your device to play in landscape mode<br>
        <div style="margin-top: 20px; font-size: 48px;">â†»</div>
    </div>
    <div id="game-container">
        <!-- Canvas will be created here by p5.js -->
    </div>

    <script>
    // Game Configuration
    const Config = {
        // Core Game Settings
        aspectRatio: 16/9,
        playerSize: 40,
        playerDistanceFromCenter: 120,
        spiritGuideSize: 18,
        
        // Controls
        tapRotationAmount: 8,  // Increased for better responsiveness
        holdBaseSpeed: 2.0,    // Increased base rotation speed
        holdAccelerationFactor: 0.0001,
        holdExponent: 2.0,
        maxHoldSpeed: 18,      // Higher max speed
        
        // Difficulty Progression
        initialWallSpeed: 1.6,  // 30% faster than original
        wallSpeedIncreaseFactor: 0.0008,
        initialSpawnInterval: 160, // Slightly faster spawn
        firstWallDelay: 100,    // First wall appears much faster (less than 2 seconds)
        spawnIntervalDecreaseFactor: 0.997,
        minSpawnInterval: 35,
        initialGapSizeDeg: 72,
        gapSizeDecreaseFactor: 0.999,
        minGapSizeDeg: 28,
        
        // Spirit Guides (replaces the center shape)
        spiritGuidesCount: 5,
        spiritGuideOrbitSpeed: 0.4,
        spiritGuideDistanceMin: 40,
        spiritGuideDistanceMax: 200,
        
        // Particles
        maxParticles: 60,
        particleLifespan: 120,
        
        // Visual Elements
        backgroundLayers: 3,
        forestElements: 80,
        cloudElements: 12,
        
        // Story Elements
        storyPhrases: [
            "Find the path forward...",
            "The walls always find you...",
            "Keep moving...",
            "Don't lose hope...",
            "Escape is possible...",
            "The curse follows...",
            "Trust the spirits...",
            "Light guides the way..."
        ],
        
        // Audio (placeholder for future enhancement)
        backgroundMusicVolume: 0.4,
        soundEffectsVolume: 0.6,
        
        // Color Themes - Ghibli Inspired
        colorThemes: [
            // Calm Forest Theme (inspired by Totoro)
            {
                name: "Forest Sanctuary",
                bg: [120, 180, 120],
                bgGradient: [100, 160, 100],
                player: [255, 250, 240],
                barriers: [60, 80, 40, 180],
                spirits: [240, 250, 200],
                particles: [220, 255, 200],
                forest: [40, 90, 40],
                clouds: [250, 250, 255, 160]
            },
            // Spirit World Theme (inspired by Spirited Away)
            {
                name: "Spirit Realm",
                bg: [70, 80, 140],
                bgGradient: [40, 50, 100],
                player: [250, 240, 255],
                barriers: [20, 30, 80, 180],
                spirits: [200, 240, 255],
                particles: [180, 220, 255],
                forest: [30, 40, 80],
                clouds: [180, 200, 255, 140]
            },
            // Castle in the Sky Theme
            {
                name: "Floating Island",
                bg: [180, 210, 255],
                bgGradient: [130, 180, 230],
                player: [255, 255, 240],
                barriers: [100, 130, 180, 180],
                spirits: [255, 255, 200],
                particles: [255, 250, 220],
                forest: [80, 120, 160],
                clouds: [255, 255, 255, 180]
            },
            // Mononoke Forest Theme
            {
                name: "Ancient Forest",
                bg: [80, 120, 80],
                bgGradient: [50, 70, 50],
                player: [240, 255, 240],
                barriers: [40, 60, 30, 180],
                spirits: [180, 255, 180],
                particles: [200, 255, 150],
                forest: [30, 60, 30],
                clouds: [230, 255, 230, 130]
            },
            // Sunset Theme (inspired by Howl's Moving Castle)
            {
                name: "Sunset Journey",
                bg: [230, 180, 100],
                bgGradient: [180, 100, 80],
                player: [255, 255, 240],
                barriers: [160, 80, 40, 180],
                spirits: [255, 220, 150],
                particles: [255, 200, 120],
                forest: [100, 60, 30],
                clouds: [255, 220, 200, 150]
            }
        ]
    };

    // Game State
    let gameState = 'intro'; // intro, story, playing, gameOver
    let storyPage = 0;
    let storyFadeIn = 0;
    let score = 0;
    let startTime = 0;
    let sessionHighScore = 0;
    let lifetimeHighScore = 0;
    let currentTheme = 0;
    let targetTheme = 0;
    let themeBlendFactor = 1;
    let firstWallSpawned = false;

    // Player State
    let playerAngle = 0;
    let playerTargetAngle = 0;
    let playerRotationSpeed = 0;
    let playerTrail = [];
    let playerGlowIntensity = 0.5;
    let playerGlowDirection = 1;
    let playerWalkFrame = 0;
    let playerWalkSpeed = 0;
    let playerFacingLeft = false;
    
    // Environment Elements
    let forestElements = [];
    let cloudElements = [];
    let spiritGuides = [];
    let particles = [];
    let barriers = [];
    let destinations = [];
    let backgroundLayers = [];
    
    // Performance Management
    let lastFrameTime = 0;
    let frameTimeHistory = [];
    let isLowPerformanceMode = false;
    
    // Display metrics
    let canvasWidth, canvasHeight;
    let gameScaleFactor;
    let gameOffsetX, gameOffsetY;
    
    // Input Tracking
    let keys = { left: false, right: false };
    let touch = { left: false, right: false };
    let holdStartTime = { left: null, right: null };
    
    // Assets
    let images = {};
    let sounds = {};
    let storyDisplayTime = 0;
    let storyTextOpacity = 0;
    let currentStoryPhrase = "";
    
    // Preload assets
    function preload() {
        // This would be where we'd load images and sounds
        // For now, we'll create them procedurally
    }
    
    // Setup function
    function setup() {
        // Create canvas with 16:9 aspect ratio that fits within the window
        setupCanvas();
        
        // Set drawing modes
        angleMode(DEGREES);
        rectMode(CENTER);
        textAlign(CENTER, CENTER);
        colorMode(RGB);
        
        // Load high scores from localStorage
        loadHighScores();
        
        // Initialize game elements
        initializeGame();
        
        // Set frame rate
        frameRate(60);
    }
    
    function setupCanvas() {
        let containerWidth = windowWidth;
        let containerHeight = windowHeight;
        
        // Calculate canvas size to maintain 16:9 ratio within the container
        if (containerWidth / containerHeight > Config.aspectRatio) {
            // Container is wider than 16:9
            canvasHeight = containerHeight;
            canvasWidth = containerHeight * Config.aspectRatio;
        } else {
            // Container is taller than 16:9
            canvasWidth = containerWidth;
            canvasHeight = containerWidth / Config.aspectRatio;
        }
        
        // Create the canvas
        createCanvas(canvasWidth, canvasHeight);
        
        // Calculate scale factor for responsive sizing
        gameScaleFactor = min(canvasWidth / 1920, canvasHeight / 1080);
        
        // Center offset
        gameOffsetX = canvasWidth / 2;
        gameOffsetY = canvasHeight / 2;
    }
    
    function initializeGame() {
        // Initialize background layers
        createBackgroundLayers();
        
        // Create forest elements
        createForestElements();
        
        // Create cloud elements
        createCloudElements();
        
        // Create spirit guides
        createSpiritGuides();
        
        // Reset player state
        resetPlayer();
        
        // Initialize empty arrays
        barriers = [];
        particles = [];
        playerTrail = [];
        destinations = [];
        
        // Start with the first theme
        currentTheme = 0;
        targetTheme = 0;
        themeBlendFactor = 1;
        
        // Reset game state
        score = 0;
        startTime = millis();
    }
    
    function resetPlayer() {
        playerAngle = 0;
        playerTargetAngle = 0;
        playerRotationSpeed = 0;
    }
    
    function createBackgroundLayers() {
        backgroundLayers = [];
        for (let i = 0; i < Config.backgroundLayers; i++) {
            // Create background layers with various depths
            backgroundLayers.push({
                depth: 0.2 + (i * 0.3),  // 0.2, 0.5, 0.8, etc.
                offset: random(360),
                speed: 0.05 + (i * 0.03)
            });
        }
    }
    
    function createForestElements() {
        forestElements = [];
        for (let i = 0; i < Config.forestElements; i++) {
            forestElements.push({
                x: random(-canvasWidth, canvasWidth * 2),
                y: random(-canvasHeight, canvasHeight * 2),
                size: random(20, 100) * gameScaleFactor,
                type: floor(random(3)),  // Different tree types
                depth: random(0.3, 1.0), // Depth for parallax
                swayAmount: random(1, 3),
                swaySpeed: random(0.5, 1.5),
                swayOffset: random(360)
            });
        }
    }
    
    function createCloudElements() {
        cloudElements = [];
        for (let i = 0; i < Config.cloudElements; i++) {
            cloudElements.push({
                x: random(-canvasWidth, canvasWidth * 2),
                y: random(-canvasHeight/2, canvasHeight/2),
                width: random(200, 400) * gameScaleFactor,
                height: random(50, 150) * gameScaleFactor,
                speed: random(0.1, 0.3),
                depth: random(0.1, 0.4)  // Clouds are always in background
            });
        }
    }
    
    function createSpiritGuides() {
        spiritGuides = [];
        for (let i = 0; i < Config.spiritGuidesCount; i++) {
            spiritGuides.push({
                angle: random(360),
                distance: random(Config.spiritGuideDistanceMin, Config.spiritGuideDistanceMax),
                size: random(Config.spiritGuideSize * 0.7, Config.spiritGuideSize * 1.3),
                speed: random(0.5, 1.5) * Config.spiritGuideOrbitSpeed,
                pulseSpeed: random(1, 3),
                phaseOffset: random(360)
            });
        }
    }
    
    // Main draw loop
    function draw() {
        try {
            // Performance monitoring
            let currentFrameTime = millis();
            if (lastFrameTime > 0) {
                let frameTime = currentFrameTime - lastFrameTime;
                frameTimeHistory.push(frameTime);
                
                // Keep only the last 60 frames for analysis
                if (frameTimeHistory.length > 60) {
                    frameTimeHistory.shift();
                }
                
                // Check if performance is low
                if (frameTimeHistory.length > 10) {
                    let avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
                    isLowPerformanceMode = avgFrameTime > 33; // More than 33ms per frame (less than 30fps)
                }
            }
            lastFrameTime = currentFrameTime;
            
            // Handle camera movement based on player angle
            let cameraAngle = -playerAngle;
            
            // Update game state
            if (gameState === 'intro') {
                drawIntroScreen();
            } else if (gameState === 'story') {
                drawStoryScreen();
            } else if (gameState === 'playing') {
                updatePlaying();
                
                // Draw world
                push();
                translate(gameOffsetX, gameOffsetY);
                rotate(cameraAngle);
                
                drawBackground();
                drawForestElements();
                updateAndDrawParticles();
                drawBarriers();
                drawSpiritGuides();
                drawDestinations();
                
                // Draw player
                drawPlayer();
                
                pop();
                
                // HUD elements (not affected by camera rotation)
                drawHUD();
                drawStoryHints();
                
                // Check for collisions
                checkCollisions();
                
            } else if (gameState === 'gameOver') {
                // Draw the world one last time (frozen)
                push();
                translate(gameOffsetX, gameOffsetY);
                rotate(cameraAngle);
                
                drawBackground();
                drawForestElements();
                updateAndDrawParticles();
                drawBarriers();
                drawSpiritGuides();
                drawDestinations();
                
                // Draw player
                drawPlayer();
                
                pop();
                
                // Draw game over screen
                drawGameOverScreen();
            }
            
            // Performance debug display (uncomment to use)
            /*
            if (isLowPerformanceMode) {
                push();
                fill(255, 0, 0, 180);
                noStroke();
                textSize(14);
                text("Low performance mode", 80, height - 10);
                pop();
            }
            */
            
        } catch (error) {
            console.log("Error in draw loop:", error);
            // Try to recover from errors by resetting state
            if (gameState === 'playing') {
                gameState = 'gameOver';
            }
        }
    }
    
    function updatePlaying() {
        // Update score
        let elapsedTimeSeconds = (millis() - startTime) / 1000;
        score = elapsedTimeSeconds;
        
        // Update difficulty based on score
        updateDifficulty();
        
        // Update player position
        updatePlayer();
        
        // Update environment
        updateEnvironment();
        
        // Initial wall spawn handling 
        if (!firstWallSpawned && frameCount > Config.firstWallDelay) {
            spawnBarriers();
            firstWallSpawned = true;
        }
        // Regular wall spawning
        else if (firstWallSpawned && frameCount % floor(currentDifficulty.spawnInterval) === 0) {
            spawnBarriers();
        }
        
        // Spawn destination when appropriate
        if (random() < 0.001 && destinations.length === 0) {
            spawnDestination();
        }
        
        // Update destinations
        updateDestinations();
        
        // Update barriers
        updateBarriers();
        
        // Check for theme changes
        checkForThemeChange();
    }
    
    // Current difficulty settings
    let currentDifficulty = {
        wallSpeed: Config.initialWallSpeed,
        spawnInterval: Config.initialSpawnInterval,
        gapSize: Config.initialGapSizeDeg
    };
    
    function updateDifficulty() {
        let elapsedTimeSeconds = score;
        
        // Increase barrier speed
        currentDifficulty.wallSpeed = Config.initialWallSpeed + 
                                      elapsedTimeSeconds * Config.wallSpeedIncreaseFactor;
        
        // Decrease spawn interval
        currentDifficulty.spawnInterval = max(Config.minSpawnInterval, 
                                           Config.initialSpawnInterval * 
                                           pow(Config.spawnIntervalDecreaseFactor, elapsedTimeSeconds));
        
        // Decrease gap size
        currentDifficulty.gapSize = max(Config.minGapSizeDeg, 
                                      Config.initialGapSizeDeg * 
                                      pow(Config.gapSizeDecreaseFactor, elapsedTimeSeconds));
    }
    
    function updatePlayer() {
        // Handle input and calculate rotation
        handleInput();
        
        // Smooth rotation towards target angle
        if (abs(playerAngle - playerTargetAngle) > 0.1) {
            playerAngle = lerp(playerAngle, playerTargetAngle, 0.4); // More responsive
        }
        
        // Apply rotation speed from holding keys/touch
        playerAngle += playerRotationSpeed;
        
        // Keep angle in 0-360 range
        playerAngle = (playerAngle + 360) % 360;
        
        // Sync target with current when actively rotating
        if (playerRotationSpeed !== 0) {
            playerTargetAngle = playerAngle;
        }
        
        // Update walking animation
        if (playerRotationSpeed !== 0) {
            // Player is moving, update walking animation
            playerWalkFrame += abs(playerRotationSpeed) * 0.1;
            if (playerWalkFrame > 4) {
                playerWalkFrame = 0;
            }
            
            // Update player direction
            playerFacingLeft = playerRotationSpeed < 0;
            
            // Set walking speed for animation
            playerWalkSpeed = abs(playerRotationSpeed) / Config.maxHoldSpeed;
        } else {
            // Player is not moving, reset animation
            playerWalkFrame = 0;
            playerWalkSpeed = 0;
        }
        
        // Update player glow (more subtle)
        playerGlowIntensity += 0.01 * playerGlowDirection;
        if (playerGlowIntensity > 0.7) {
            playerGlowIntensity = 0.7;
            playerGlowDirection = -1;
        } else if (playerGlowIntensity < 0.4) {
            playerGlowIntensity = 0.4;
            playerGlowDirection = 1;
        }
        
        // Update player trail
        updatePlayerTrail();
    }
    
    function updatePlayerTrail() {
        // Add new trail point
        playerTrail.push({
            angle: playerAngle,
            distance: Config.playerDistanceFromCenter,
            alpha: 255,
            size: Config.playerSize * 0.4
        });
        
        // Remove old points
        if (playerTrail.length > 12) {
            playerTrail.shift();
        }
        
        // Fade out trail points
        for (let i = 0; i < playerTrail.length; i++) {
            playerTrail[i].alpha -= 255 / 12;
            playerTrail[i].size *= 0.92;
        }
    }
    
    function updateEnvironment() {
        // Move clouds
        for (let cloud of cloudElements) {
            cloud.x += cloud.speed;
            if (cloud.x > canvasWidth * 1.5) {
                cloud.x = -canvasWidth / 2;
                cloud.y = random(-canvasHeight/2, canvasHeight/2);
            }
        }
    }
    
    function spawnBarriers() {
        // Calculate starting distance (outside visible area)
        let spawnDistance = max(canvasWidth, canvasHeight) * 1.2;
        
        // Number of barrier segments around the circle
        let numSegments = 8;
        let segmentAngle = 360 / numSegments;
        
        // Choose a safe segment for the gap
        let safeSegment = floor(random(numSegments));
        
        // Create barrier segments
        for (let i = 0; i < numSegments; i++) {
            // Skip the safe segment
            if (i === safeSegment) continue;
            
            let startAngle = i * segmentAngle;
            let endAngle = (i + 1) * segmentAngle;
            
            // Create the barrier
            barriers.push({
                startAngle: startAngle,
                endAngle: endAngle,
                distance: spawnDistance,
                thickness: 40 * gameScaleFactor,
                alpha: 0, // Start transparent and fade in
                safePassage: false
            });
        }
        
        // Add hint particles in the safe passage
        let safeAngle = safeSegment * segmentAngle + segmentAngle / 2;
        for (let i = 0; i < 5; i++) {
            addSafePassageParticle(safeAngle, spawnDistance);
        }
    }
    
    function updateBarriers() {
        for (let i = barriers.length - 1; i >= 0; i--) {
            // Move barriers inward
            barriers[i].distance -= currentDifficulty.wallSpeed * (deltaTime / 16);
            
            // Fade in barriers as they enter the screen
            if (barriers[i].alpha < 255) {
                barriers[i].alpha += 5;
            }
            
            // Remove barriers that have passed the center
            if (barriers[i].distance < 10) {
                barriers.splice(i, 1);
                continue;
            }
            
            // Check if barrier is approaching player's orbit
            let distanceToPlayer = abs(barriers[i].distance - Config.playerDistanceFromCenter);
            if (distanceToPlayer < 50 && distanceToPlayer > 40) {
                // Add warning particle effect
                let midAngle = (barriers[i].startAngle + barriers[i].endAngle) / 2;
                addWarningParticles(midAngle, barriers[i].distance);
            }
        }
    }
    
    function spawnDestination() {
        destinations.push({
            distance: max(canvasWidth, canvasHeight) * 1.2,
            radius: 80 * gameScaleFactor,
            pulseAmount: 0.2,
            pulseSpeed: 2,
            alpha: 0
        });
    }
    
    function updateDestinations() {
        try {
            for (let i = destinations.length - 1; i >= 0; i--) {
                // Validate destination object
                if (!destinations[i]) {
                    console.log("Invalid destination detected and removed");
                    destinations.splice(i, 1);
                    continue;
                }
                
                // Move destination inward
                destinations[i].distance -= (currentDifficulty.wallSpeed * 0.8) * (deltaTime / 16);
                
                // Fade in destination
                if (destinations[i].distance < max(canvasWidth, canvasHeight) && destinations[i].alpha < 255) {
                    destinations[i].alpha += 2;
                }
                
                // Check if player reached the destination
                if (destinations[i].distance < Config.playerDistanceFromCenter + 20 && 
                    destinations[i].distance > Config.playerDistanceFromCenter - 20) {
                    
                    // Player reached destination - spawn barriers and remove destination
                    try {
                        // Limit number of barriers based on performance
                        let numBarriers = isLowPerformanceMode ? 8 : 12;
                        let barrierAngleSpacing = 360 / numBarriers;
                        
                        // Create a safe zone where player is
                        let playerSafeZoneStart = playerAngle - barrierAngleSpacing/2;
                        let playerSafeZoneEnd = playerAngle + barrierAngleSpacing/2;
                        
                        for (let j = 0; j < numBarriers; j++) {
                            let startAngle = j * barrierAngleSpacing;
                            let endAngle = (j + 1) * barrierAngleSpacing;
                            
                            // Skip creating a barrier if it would overlap with player
                            if ((playerAngle >= startAngle && playerAngle <= endAngle) ||
                                (startAngle >= playerSafeZoneStart && startAngle <= playerSafeZoneEnd) ||
                                (endAngle >= playerSafeZoneStart && endAngle <= playerSafeZoneEnd)) {
                                continue;
                            }
                            
                            barriers.push({
                                startAngle: startAngle,
                                endAngle: endAngle,
                                distance: Config.playerDistanceFromCenter + 100,
                                thickness: 40 * gameScaleFactor,
                                alpha: 0,
                                safePassage: false
                            });
                        }
                        
                        // Add special particles
                        let particleCount = isLowPerformanceMode ? 15 : 30;
                        for (let j = 0; j < particleCount; j++) {
                            addParticle(
                                Config.playerDistanceFromCenter * cos(playerAngle),
                                Config.playerDistanceFromCenter * sin(playerAngle),
                                random(-2, 2),
                                random(-2, 2),
                                random(8, 20),
                                [255, 255, 200],
                                random(60, 120)
                            );
                        }
                        
                        // Change theme with a small delay to prevent freezing
                        setTimeout(() => {
                            changeTheme();
                        }, 50);
                        
                    } catch (error) {
                        console.log("Error in destination collision handling:", error);
                    }
                    
                    // Remove the destination
                    destinations.splice(i, 1);
                    continue;
                }
                
                // Remove destinations that have passed the center
                if (destinations[i].distance < 10) {
                    destinations.splice(i, 1);
                }
            }
        } catch (error) {
            console.log("Error in updateDestinations:", error);
        }
    }
    
    function addSafePassageParticle(angle, distance) {
        let x = distance * cos(angle);
        let y = distance * sin(angle);
        
        addParticle(
            x, y,
            random(-1, 1),
            random(-1, 1),
            random(8, 15) * gameScaleFactor,
            [255, 255, 200],
            random(60, 120)
        );
    }
    
    function addWarningParticles(angle, distance) {
        if (random() < 0.3) {
            let x = distance * cos(angle);
            let y = distance * sin(angle);
            
            addParticle(
                x, y,
                random(-0.5, 0.5),
                random(-0.5, 0.5),
                random(5, 10) * gameScaleFactor,
                [255, 100, 50],
                random(20, 40)
            );
        }
    }
    
    function addParticle(x, y, vx, vy, size, color, lifespan) {
        if (particles.length > Config.maxParticles) {
            // Remove oldest particle if at limit
            particles.shift();
        }
        
        particles.push({
            x: x,
            y: y,
            vx: vx,
            vy: vy,
            size: size,
            color: color,
            lifespan: lifespan,
            maxLifespan: lifespan
        });
    }
    
    function updateAndDrawParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            
            // Update position
            p.x += p.vx;
            p.y += p.vy;
            
            // Decrease lifespan
            p.lifespan--;
            
            // Remove dead particles
            if (p.lifespan <= 0) {
                particles.splice(i, 1);
                continue;
            }
            
            // Draw particle
            let alpha = 255 * (p.lifespan / p.maxLifespan);
            let size = p.size * (0.5 + 0.5 * (p.lifespan / p.maxLifespan));
            
            fill(p.color[0], p.color[1], p.color[2], alpha);
            noStroke();
            ellipse(p.x, p.y, size, size);
        }
    }
    
    function checkCollisions() {
        try {
            let playerRadius = Config.playerDistanceFromCenter;
            
            // Check if there are any invalid barriers and remove them
            for (let i = barriers.length - 1; i >= 0; i--) {
                if (!barriers[i] || typeof barriers[i].distance !== 'number') {
                    console.log("Found invalid barrier, removing");
                    barriers.splice(i, 1);
                    continue;
                }
            }
            
            // Check collisions with barriers
            for (let barrier of barriers) {
                // Ensure barrier has all necessary properties
                if (!barrier || typeof barrier.distance !== 'number' ||
                    typeof barrier.thickness !== 'number' ||
                    typeof barrier.startAngle !== 'number' ||
                    typeof barrier.endAngle !== 'number') {
                    continue; // Skip invalid barriers
                }
                
                // Check if barrier is near player's orbit
                let distToBarrier = abs(barrier.distance - playerRadius);
                
                if (distToBarrier < barrier.thickness / 2) {
                    // Check if player angle is within barrier's angles - with a small forgiveness margin
                    let playerAngleNormalized = (playerAngle + 360) % 360;
                    let startAngleNormalized = ((barrier.startAngle + 2) + 360) % 360; // +2 degree forgiveness
                    let endAngleNormalized = ((barrier.endAngle - 2) + 360) % 360;     // -2 degree forgiveness
                    
                    let collision = false;
                    
                    // Handle angle wrap-around
                    if (startAngleNormalized < endAngleNormalized) {
                        if (playerAngleNormalized >= startAngleNormalized && 
                            playerAngleNormalized <= endAngleNormalized) {
                            collision = true;
                        }
                    } else {
                        if (playerAngleNormalized >= startAngleNormalized || 
                            playerAngleNormalized <= endAngleNormalized) {
                            collision = true;
                        }
                    }
                    
                    if (collision) {
                        // Collision detected!
                        gameOver();
                        return;
                    }
                }
            }
        } catch (error) {
            console.log("Error in collision detection:", error);
        }
    }
    
    function gameOver() {
        gameState = 'gameOver';
        
        // Add explosion particles
        for (let i = 0; i < 40; i++) {
            let angle = random(360);
            let distance = random(10, 30);
            let x = Config.playerDistanceFromCenter * cos(playerAngle) + distance * cos(angle);
            let y = Config.playerDistanceFromCenter * sin(playerAngle) + distance * sin(angle);
            
            addParticle(
                x, y,
                random(-3, 3),
                random(-3, 3),
                random(5, 20) * gameScaleFactor,
                [255, 200, 100],
                random(60, 120)
            );
        }
        
        // Update high scores
        if (score > sessionHighScore) {
            sessionHighScore = score;
        }
        
        if (score > lifetimeHighScore) {
            lifetimeHighScore = score;
            // Save to localStorage
            saveHighScores();
        }
    }
    
    function checkForThemeChange() {
        // Change theme based on score milestones
        let themeIndex = floor(min(score / 30, Config.colorThemes.length - 1));
        
        if (themeIndex !== targetTheme) {
            targetTheme = themeIndex;
            themeBlendFactor = 0;
        }
        
        // Blend themes
        if (themeBlendFactor < 1) {
            themeBlendFactor += 0.01;
        }
    }
    
    function changeTheme() {
        // Choose a new theme different from the current one
        let newTheme;
        do {
            newTheme = floor(random(Config.colorThemes.length));
        } while (newTheme === targetTheme);
        
        targetTheme = newTheme;
        themeBlendFactor = 0;
    }
    
    function getCurrentThemeColors() {
        if (themeBlendFactor >= 1) {
            return Config.colorThemes[targetTheme];
        }
        
        // Blend between current and target theme
        let current = Config.colorThemes[currentTheme];
        let target = Config.colorThemes[targetTheme];
        
        let blended = {};
        
        for (let key in current) {
            if (Array.isArray(current[key])) {
                blended[key] = current[key].map((val, i) => {
                    return lerp(val, target[key][i], themeBlendFactor);
                });
            } else {
                blended[key] = lerp(current[key], target[key], themeBlendFactor);
            }
        }
        
        return blended;
    }
    
    // Drawing functions
    
    function drawBackground() {
        let themeColors = getCurrentThemeColors();
        
        // Draw gradient background
        let gradientStart = color(themeColors.bg[0], themeColors.bg[1], themeColors.bg[2]);
        let gradientEnd = color(themeColors.bgGradient[0], themeColors.bgGradient[1], themeColors.bgGradient[2]);
        
        // Draw layered background
        for (let layer of backgroundLayers) {
            push();
            rotate(frameCount * layer.speed + layer.offset);
            
            let layerSize = max(canvasWidth, canvasHeight) * 2 * layer.depth;
            let layerAlpha = map(layer.depth, 0.2, 0.8, 80, 20);
            
            noStroke();
            fill(lerpColor(gradientStart, gradientEnd, layer.depth), layerAlpha);
            ellipse(0, 0, layerSize, layerSize);
            pop();
        }
    }
    
    function drawForestElements() {
        let themeColors = getCurrentThemeColors();
        
        // Calculate player's angle in radians for parallax
        let playerRad = radians(playerAngle);
        
        for (let tree of forestElements) {
            // Apply parallax effect based on depth
            let parallaxX = -sin(playerRad) * tree.depth * 100;
            let parallaxY = cos(playerRad) * tree.depth * 100;
            
            // Calculate sway
            let sway = sin(frameCount * tree.swaySpeed + tree.swayOffset) * tree.swayAmount;
            
            push();
            translate(tree.x + parallaxX, tree.y + parallaxY);
            rotate(sway);
            
            // Draw tree based on type
            noStroke();
            
            // Tree trunk
            fill(100, 70, 40, 150);
            rect(0, 0, tree.size * 0.2, tree.size * 0.8);
            
            // Tree foliage
            fill(themeColors.forest[0], themeColors.forest[1], themeColors.forest[2], 150);
            
            if (tree.type === 0) {
                // Rounded top tree
                ellipse(0, -tree.size * 0.3, tree.size * 0.7, tree.size * 0.7);
            } else if (tree.type === 1) {
                // Triangular tree
                triangle(-tree.size * 0.4, tree.size * 0.1,
                         tree.size * 0.4, tree.size * 0.1,
                         0, -tree.size * 0.7);
            } else {
                // Bushy tree
                ellipse(0, -tree.size * 0.2, tree.size * 0.5, tree.size * 0.5);
                ellipse(-tree.size * 0.2, -tree.size * 0.4, tree.size * 0.4, tree.size * 0.4);
                ellipse(tree.size * 0.2, -tree.size * 0.4, tree.size * 0.4, tree.size * 0.4);
                ellipse(0, -tree.size * 0.6, tree.size * 0.3, tree.size * 0.3);
            }
            
            pop();
        }
        
        // Draw clouds
        for (let cloud of cloudElements) {
            // Apply parallax effect
            let parallaxX = -sin(playerRad) * cloud.depth * 200;
            let parallaxY = cos(playerRad) * cloud.depth * 200;
            
            push();
            translate(cloud.x + parallaxX, cloud.y + parallaxY);
            
            // Draw cloud
            noStroke();
            fill(themeColors.clouds[0], themeColors.clouds[1], themeColors.clouds[2], themeColors.clouds[3]);
            
            ellipse(0, 0, cloud.width * 0.5, cloud.height);
            ellipse(cloud.width * 0.3, 0, cloud.width * 0.4, cloud.height * 0.9);
            ellipse(-cloud.width * 0.3, 0, cloud.width * 0.4, cloud.height * 0.8);
            ellipse(cloud.width * 0.1, -cloud.height * 0.2, cloud.width * 0.3, cloud.height * 0.6);
            
            pop();
        }
    }
    
    function drawSpiritGuides() {
        let themeColors = getCurrentThemeColors();
        
        for (let spirit of spiritGuides) {
            // Calculate position
            let angle = spirit.angle + frameCount * spirit.speed;
            let distance = spirit.distance;
            
            // Add bobbing motion
            distance += sin(frameCount * spirit.pulseSpeed + spirit.phaseOffset) * 10;
            
            // Calculate x, y
            let x = distance * cos(angle);
            let y = distance * sin(angle);
            
            // Draw spirit guide
            push();
            translate(x, y);
            
            // Glow effect
            let glowSize = spirit.size * (1.5 + sin(frameCount * 0.1 + spirit.phaseOffset) * 0.2);
            let glowAlpha = 100 + sin(frameCount * 0.2 + spirit.phaseOffset) * 50;
            
            fill(themeColors.spirits[0], themeColors.spirits[1], themeColors.spirits[2], glowAlpha);
            ellipse(0, 0, glowSize, glowSize);
            
            // Core
            fill(255, 255, 255, 200);
            ellipse(0, 0, spirit.size, spirit.size);
            
            pop();
            
            // Occasionally emit particles
            if (random() < 0.1) {
                addParticle(
                    x, y,
                    random(-0.5, 0.5),
                    random(-0.5, 0.5),
                    random(3, 8) * gameScaleFactor,
                    themeColors.particles,
                    random(30, 60)
                );
            }
        }
    }
    
    function drawBarriers() {
        let themeColors = getCurrentThemeColors();
        
        noFill();
        strokeCap(PROJECT);
        
        for (let barrier of barriers) {
            // Calculate barrier properties
            let innerRadius = barrier.distance - barrier.thickness / 2;
            let outerRadius = barrier.distance + barrier.thickness / 2;
            
            // Draw outer edge
            strokeWeight(2);
            stroke(themeColors.barriers[0], themeColors.barriers[1], themeColors.barriers[2], barrier.alpha * 0.7);
            arc(0, 0, outerRadius * 2, outerRadius * 2, barrier.startAngle, barrier.endAngle);
            
            // Draw inner edge
            stroke(themeColors.barriers[0], themeColors.barriers[1], themeColors.barriers[2], barrier.alpha * 0.7);
            arc(0, 0, innerRadius * 2, innerRadius * 2, barrier.startAngle, barrier.endAngle);
            
            // Draw connecting lines
            strokeWeight(1);
            line(
                innerRadius * cos(barrier.startAngle), innerRadius * sin(barrier.startAngle),
                outerRadius * cos(barrier.startAngle), outerRadius * sin(barrier.startAngle)
            );
            
            line(
                innerRadius * cos(barrier.endAngle), innerRadius * sin(barrier.endAngle),
                outerRadius * cos(barrier.endAngle), outerRadius * sin(barrier.endAngle)
            );
            
            // Fill with semi-transparent color
            fill(themeColors.barriers[0], themeColors.barriers[1], themeColors.barriers[2], barrier.alpha * 0.4);
            beginShape();
            vertex(innerRadius * cos(barrier.startAngle), innerRadius * sin(barrier.startAngle));
            vertex(outerRadius * cos(barrier.startAngle), outerRadius * sin(barrier.startAngle));
            
            let steps = 10;
            for (let i = 0; i <= steps; i++) {
                let a = map(i, 0, steps, barrier.startAngle, barrier.endAngle);
                vertex(outerRadius * cos(a), outerRadius * sin(a));
            }
            
            vertex(outerRadius * cos(barrier.endAngle), outerRadius * sin(barrier.endAngle));
            vertex(innerRadius * cos(barrier.endAngle), innerRadius * sin(barrier.endAngle));
            
            for (let i = steps; i >= 0; i--) {
                let a = map(i, 0, steps, barrier.startAngle, barrier.endAngle);
                vertex(innerRadius * cos(a), innerRadius * sin(a));
            }
            
            endShape(CLOSE);
            noFill();
        }
    }
    
    function drawDestinations() {
        let themeColors = getCurrentThemeColors();
        
        for (let dest of destinations) {
            // Calculate pulse size
            let pulseAmount = 1 + sin(frameCount * 0.1) * dest.pulseAmount;
            let radius = dest.radius * pulseAmount;
            
            // Draw destination portal
            push();
            noFill();
            stroke(255, 255, 255, dest.alpha * 0.7);
            strokeWeight(3);
            ellipse(0, 0, dest.distance * 2, dest.distance * 2);
            
            // Draw portal
            for (let i = 0; i < 3; i++) {
                let alpha = map(i, 0, 2, 0.8, 0.2) * dest.alpha;
                stroke(themeColors.spirits[0], themeColors.spirits[1], themeColors.spirits[2], alpha);
                strokeWeight(3 - i);
                ellipse(0, 0, dest.distance * 2 - i * 10, dest.distance * 2 - i * 10);
            }
            
            // Draw radial lines
            stroke(255, 255, 255, dest.alpha * 0.3);
            strokeWeight(1);
            for (let i = 0; i < 12; i++) {
                let angle = i * 30 + frameCount * 0.2;
                line(
                    (dest.distance - 20) * cos(angle), (dest.distance - 20) * sin(angle),
                    (dest.distance + 20) * cos(angle), (dest.distance + 20) * sin(angle)
                );
            }
            
            pop();
            
            // Emit particles occasionally
            if (random() < 0.3) {
                let angle = random(360);
                let x = dest.distance * cos(angle);
                let y = dest.distance * sin(angle);
                
                addParticle(
                    x, y,
                    random(-1, 1),
                    random(-1, 1),
                    random(5, 12) * gameScaleFactor,
                    themeColors.particles,
                    random(40, 80)
                );
            }
        }
    }
    
    function drawPlayer() {
        let themeColors = getCurrentThemeColors();
        
        // Calculate player position
        let x = Config.playerDistanceFromCenter * cos(playerAngle);
        let y = Config.playerDistanceFromCenter * sin(playerAngle);
        
        // Draw player trail
        for (let i = 0; i < playerTrail.length; i++) {
            let point = playerTrail[i];
            let trailX = point.distance * cos(point.angle);
            let trailY = point.distance * sin(point.angle);
            
            noStroke();
            fill(themeColors.player[0], themeColors.player[1], themeColors.player[2], point.alpha * 0.7);
            ellipse(trailX, trailY, point.size, point.size);
        }
        
        // Draw player (Ghibli-style stick figure)
        push();
        translate(x, y);
        rotate(playerAngle + 90); // Rotate to face direction of travel
        
        // Subtle glow effect
        let glowSize = Config.playerSize * (1.3 + playerGlowIntensity * 0.3);
        noStroke();
        fill(themeColors.player[0], themeColors.player[1], themeColors.player[2], 60 * playerGlowIntensity);
        ellipse(0, 0, glowSize, glowSize);
        
        // Scale to correct size
        let characterSize = Config.playerSize * 1.2;
        scale(characterSize / 100);
        
        // Determine character orientation based on movement
        let mirrorFactor = playerFacingLeft ? -1 : 1;
        scale(mirrorFactor, 1);
        
        // Draw Ghibli-style stick figure character
        // Draw legs based on walk cycle
        strokeWeight(2);
        stroke(20, 20, 20, 150);
        
        if (playerWalkSpeed > 0) {
            // Walking animation
            let legSwing = sin(playerWalkFrame * PI) * 20 * playerWalkSpeed;
            
            // Left leg
            line(0, 0, -10 - legSwing, 25);
            line(-10 - legSwing, 25, -5 - legSwing/2, 40);
            
            // Right leg
            line(0, 0, 10 + legSwing, 25);
            line(10 + legSwing, 25, 5 + legSwing/2, 40);
        } else {
            // Standing position
            line(0, 0, -8, 25);
            line(-8, 25, -5, 42);
            
            line(0, 0, 8, 25);
            line(8, 25, 5, 42);
        }
        
        // Torso
        stroke(40, 40, 40, 170);
        strokeWeight(3);
        line(0, 0, 0, -25);
        
        // Arms based on walk cycle
        if (playerWalkSpeed > 0) {
            // Moving arms
            let armSwing = cos(playerWalkFrame * PI) * 15 * playerWalkSpeed;
            
            // Left arm
            line(0, -20, -12 - armSwing, -5);
            line(-12 - armSwing, -5, -18 - armSwing, 10);
            
            // Right arm
            line(0, -20, 12 + armSwing, -5);
            line(12 + armSwing, -5, 18 + armSwing, 10);
        } else {
            // Resting arms
            line(0, -20, -15, -5);
            line(-15, -5, -12, 10);
            
            line(0, -20, 15, -5);
            line(15, -5, 12, 10);
        }
        
        // Head (with slight bobbing when walking)
        let headBob = playerWalkSpeed > 0 ? sin(playerWalkFrame * PI * 2) * 2 * playerWalkSpeed : 0;
        fill(255, 240, 220);
        stroke(40, 40, 40, 180);
        strokeWeight(1.5);
        ellipse(0, -35 + headBob, 20, 20);
        
        // Simple face (eyes and mouth)
        fill(50, 40, 30);
        noStroke();
        
        // Eyes
        ellipse(-5, -37 + headBob, 2, 3);
        ellipse(5, -37 + headBob, 2, 3);
        
        // Mouth - changes with movement
        if (playerWalkSpeed > 0.5) {
            // Determined expression when moving fast
            stroke(50, 40, 30);
            strokeWeight(1);
            noFill();
            arc(0, -32 + headBob, 8, 3, 0, 180);
        } else {
            // Neutral expression
            stroke(50, 40, 30);
            strokeWeight(1);
            line(-3, -32 + headBob, 3, -32 + headBob);
        }
        
        // Hair - simple Ghibli style
        stroke(20, 20, 20);
        strokeWeight(1.5);
        fill(80, 60, 30);
        
        beginShape();
        vertex(-10, -45 + headBob);
        vertex(-5, -48 + headBob);
        vertex(0, -44 + headBob);
        vertex(5, -48 + headBob);
        vertex(10, -45 + headBob);
        vertex(10, -35 + headBob);
        vertex(-10, -35 + headBob);
        endShape(CLOSE);
        
        // Small backpack/bag
        fill(160, 120, 80);
        stroke(80, 60, 40);
        strokeWeight(1);
        ellipse(0, -15, 14, 18);
        
        // Occasionally emit subtle particles when moving
        if (playerWalkSpeed > 0 && random() < 0.1) {
            let particleX = (random(-20, 20)) / 100 * characterSize;
            let particleY = (random(30, 50)) / 100 * characterSize;
            let worldX = (particleX * cos(playerAngle + 90) - particleY * sin(playerAngle + 90)) + x;
            let worldY = (particleX * sin(playerAngle + 90) + particleY * cos(playerAngle + 90)) + y;
            
            addParticle(
                worldX, worldY,
                random(-0.5, 0.5),
                random(-0.5, 0.5),
                random(3, 8) * gameScaleFactor,
                [255, 255, 255],
                random(10, 30)
            );
        }
        
        pop();
    }
    
    function drawHUD() {
        let themeColors = getCurrentThemeColors();
        
        // Score display with improved visibility
        push();
        // Text shadow for better readability
        textFont('Mali');
        textStyle(BOLD);
        textSize(32 * gameScaleFactor);
        textAlign(RIGHT, TOP);
        
        // Shadow
        fill(20, 20, 20, 120);
        text(`Time: ${score.toFixed(1)}s`, canvasWidth - 18, 22);
        
        // Actual text
        fill(255, 240, 220, 230);
        text(`Time: ${score.toFixed(1)}s`, canvasWidth - 20, 20);
        
        // Theme name with improved styling
        textAlign(LEFT, TOP);
        textFont('Quicksand');
        textStyle(NORMAL);
        textSize(28 * gameScaleFactor);
        
        // Text shadow
        fill(20, 20, 20, 100);
        text(themeColors.name, 22, 22);
        
        // Actual text with glow effect
        fill(themeColors.spirits[0], themeColors.spirits[1], themeColors.spirits[2], 230);
        text(themeColors.name, 20, 20);
        
        // Add subtle glow around text
        noFill();
        strokeWeight(3);
        stroke(themeColors.spirits[0], themeColors.spirits[1], themeColors.spirits[2], 60);
        text(themeColors.name, 20, 20);
        pop();
    }
    
    function drawStoryHints() {
        // Update story phrase timing
        if (frameCount % 300 === 0 || currentStoryPhrase === "") {
            currentStoryPhrase = random(Config.storyPhrases);
            storyTextOpacity = 0;
            storyDisplayTime = 0;
        }
        
        storyDisplayTime++;
        
        if (storyDisplayTime < 60) {
            storyTextOpacity = min(storyTextOpacity + 2, 180); // Increased opacity
        } else if (storyDisplayTime > 240) {
            storyTextOpacity = max(storyTextOpacity - 2, 0);
        }
        
        // Draw story hint with improved styling
        if (storyTextOpacity > 0) {
            push();
            textFont('Mali');
            textAlign(CENTER, CENTER);
            textSize(24 * gameScaleFactor); // Larger text
            
            // Draw text shadow for better readability
            fill(20, 20, 20, storyTextOpacity * 0.6);
            text(currentStoryPhrase, canvasWidth / 2 + 2, canvasHeight - 58);
            
            // Draw main text
            fill(255, 255, 250, storyTextOpacity);
            text(currentStoryPhrase, canvasWidth / 2, canvasHeight - 60);
            
            // Add subtle glow around text
            noFill();
            strokeWeight(3);
            stroke(255, 255, 240, storyTextOpacity * 0.3);
            text(currentStoryPhrase, canvasWidth / 2, canvasHeight - 60);
            pop();
        }
    }
    
    function drawIntroScreen() {
        let themeColors = Config.colorThemes[0];
        
        // Draw animated background with gradient
        let gradientY = height/2;
        setGradient(0, 0, width, height, 
                   color(themeColors.bg[0]*0.8, themeColors.bg[1]*0.8, themeColors.bg[2]*0.8), 
                   color(themeColors.bg[0]*1.2, themeColors.bg[1]*1.2, themeColors.bg[2]*1.2));
        
        // Draw animated elements in background
        push();
        translate(gameOffsetX, gameOffsetY);
        
        // Enhanced animated circles
        noFill();
        for (let i = 0; i < 5; i++) {
            let size = 100 + i * 80 + sin(frameCount * 0.02 + i) * 20;
            stroke(themeColors.spirits[0], themeColors.spirits[1], themeColors.spirits[2], 120 - i * 15);
            strokeWeight(2 + (5-i)*0.5);
            ellipse(0, 0, size, size);
        }
        
        // Additional decorative arcs
        for (let i = 0; i < 6; i++) {
            let rotation = frameCount * 0.1 + i * 60;
            push();
            rotate(rotation);
            stroke(255, 255, 255, 50);
            strokeWeight(1);
            noFill();
            arc(0, 0, 300, 300, 0, 120);
            pop();
        }
        
        // Draw more particles for liveliness
        if (random() < 0.3) {
            let angle = random(360);
            let distance = random(50, 250);
            addParticle(
                distance * cos(angle),
                distance * sin(angle),
                random(-0.7, 0.7),
                random(-0.7, 0.7),
                random(7, 18),
                themeColors.particles,
                random(80, 150)
            );
        }
        
        updateAndDrawParticles();
        pop();
        
        // Game title with enhanced styling
        push();
        textAlign(CENTER, CENTER);
        textFont('Mali');
        textStyle(BOLD);
        
        // Title glow
        for (let i = 5; i > 0; i--) {
            let alpha = map(i, 5, 0, 30, 100);
            fill(themeColors.spirits[0], themeColors.spirits[1], themeColors.spirits[2], alpha);
            textSize((60 + i*2) * gameScaleFactor);
            text("The Cursed Traveler", canvasWidth / 2, canvasHeight * 0.3);
        }
        
        // Main title
        fill(255, 250, 245);
        textSize(60 * gameScaleFactor);
        text("The Cursed Traveler", canvasWidth / 2, canvasHeight * 0.3);
        
        // Subtitle with enhanced styling
        textFont('Quicksand');
        textStyle(NORMAL);
        textSize(32 * gameScaleFactor);
        
        // Subtitle shadow
        fill(20, 20, 20, 100);
        text("A Journey of Escape", canvasWidth / 2 + 2, canvasHeight * 0.4 + 2);
        
        // Subtitle main text
        fill(themeColors.spirits[0], themeColors.spirits[1], themeColors.spirits[2], 230);
        text("A Journey of Escape", canvasWidth / 2, canvasHeight * 0.4);
        
        // Instructions with improved readability
        textFont('Quicksand');
        textSize(24 * gameScaleFactor);
        fill(255, 250, 240, 220);
        text("Use arrow keys or tap left/right to rotate", canvasWidth / 2, canvasHeight * 0.6);
        text("Avoid barriers as you journey through realms", canvasWidth / 2, canvasHeight * 0.65);
        
        // Start button
        let buttonY = canvasHeight * 0.75;
        let buttonWidth = 200 * gameScaleFactor;
        let buttonHeight = 60 * gameScaleFactor;
        let buttonLeft = canvasWidth / 2 - buttonWidth / 2;
        let buttonRight = buttonLeft + buttonWidth;
        let buttonTop = buttonY - buttonHeight / 2;
        let buttonBottom = buttonTop + buttonHeight;
        
        // Button highlight if mouse is over
        let buttonHighlight = (
            mouseX >= buttonLeft && mouseX <= buttonRight &&
            mouseY >= buttonTop && mouseY <= buttonBottom
        );
        
        // Draw the button
        fill(buttonHighlight ? 
             color(themeColors.spirits[0], themeColors.spirits[1], themeColors.spirits[2]) : 
             color(themeColors.barriers[0], themeColors.barriers[1], themeColors.barriers[2]));
        stroke(255, 150);
        strokeWeight(2);
        rect(canvasWidth / 2, buttonY, buttonWidth, buttonHeight, 10);
        
        // Button text
        fill(255);
        noStroke();
        textSize(24 * gameScaleFactor);
        text("Begin Journey", canvasWidth / 2, buttonY);
        
        // Read story button
        let storyButtonY = buttonY + buttonHeight + 20;
        fill(buttonHighlight ? 150 : 100);
        noStroke();
        textSize(18 * gameScaleFactor);
        text("Read the Story", canvasWidth / 2, storyButtonY);
        
        pop();
        
        // Check for button clicks
        if (mouseIsPressed && buttonHighlight) {
            startGame();
        }
    }
    
    // Helper function for gradients
    function setGradient(x, y, w, h, c1, c2) {
        noFill();
        for (let i = y; i <= y + h; i++) {
            let inter = map(i, y, y + h, 0, 1);
            let c = lerpColor(c1, c2, inter);
            stroke(c);
            line(x, i, x + w, i);
        }
    }

    function drawStoryScreen() {
        let themeColors = Config.colorThemes[0];
        
        // Draw animated background with subtle gradient
        setGradient(0, 0, width, height, 
                   color(themeColors.bg[0] * 0.5, themeColors.bg[1] * 0.5, themeColors.bg[2] * 0.5), 
                   color(themeColors.bg[0] * 0.8, themeColors.bg[1] * 0.8, themeColors.bg[2] * 0.8));
        
        // Draw subtle background elements
        push();
        translate(gameOffsetX, gameOffsetY);
        
        // Decorative circles
        noFill();
        for (let i = 0; i < 3; i++) {
            stroke(255, 255, 255, 20 + i * 5);
            strokeWeight(1);
            ellipse(0, 0, 300 + i * 200, 300 + i * 200);
        }
        
        // Occasional gentle particles
        if (random() < 0.1) {
            let angle = random(360);
            let distance = random(50, 350);
            addParticle(
                distance * cos(angle),
                distance * sin(angle),
                random(-0.3, 0.3),
                random(-0.3, 0.3),
                random(5, 15),
                [255, 255, 255],
                random(60, 120)
            );
        }
        
        updateAndDrawParticles();
        pop();
        
        // Draw story content with improved typography
        push();
        textAlign(CENTER, TOP);
        
        // Fade in effect
        if (storyFadeIn < 255) {
            storyFadeIn += 5;
        }
        
        // Story title with enhanced styling
        textFont('Mali');
        textStyle(BOLD);
        
        // Title shadow
        fill(20, 20, 20, storyFadeIn * 0.5);
        textSize(42 * gameScaleFactor);
        text("The Curse of Endless Barriers", canvasWidth / 2 + 2, canvasHeight * 0.15 + 2);
        
        // Title main text with glow
        for (let i = 3; i > 0; i--) {
            let alpha = map(i, 3, 0, 30, storyFadeIn);
            fill(255, 250, 220, alpha);
            textSize((42 + i) * gameScaleFactor);
            text("The Curse of Endless Barriers", canvasWidth / 2, canvasHeight * 0.15);
        }
        
        fill(255, 250, 220, storyFadeIn);
        textSize(42 * gameScaleFactor);
        text("The Curse of Endless Barriers", canvasWidth / 2, canvasHeight * 0.15);
        
        // Story content with improved readability
        textFont('Quicksand');
        textStyle(NORMAL);
        fill(255, 245, 225, storyFadeIn);
        textSize(24 * gameScaleFactor); // Larger, more readable text
        textAlign(LEFT, TOP);
        
        let storyText;
        if (storyPage === 0) {
            storyText = "In a realm where spirits guide and shadows follow, there lived a traveler known for finding paths others could not see.\n\n" +
                       "The traveler's gift drew the envy of a powerful entity who placed a curse upon them: 'May walls close in around you whenever you approach your destination.'\n\n" +
                       "From that day forward, the traveler found that each place they journeyed to would suddenly manifest closing barriers, threatening to trap them forever.";
        } else if (storyPage === 1) {
            storyText = "The spirits of the forest took pity on the traveler. They couldn't break the curse, but they offered guidance - faint glimmers of light showing safe passages through the appearing walls.\n\n" +
                       "The traveler learned to follow these spirit guides, moving quickly through the gaps before the barriers could close completely.\n\n" +
                       "Now, they journey endlessly from one realm to another, always moving, always escaping, guided by ancient spirits through an endless series of closing barriers.";
        } else {
            storyText = "As you take control of the cursed traveler's journey, remember:\n\n" +
                       "- Move swiftly but with purpose\n" +
                       "- Trust the spirit guides that show safe paths\n" +
                       "- Each realm you reach brings new challenges\n" +
                       "- The curse cannot be broken, only outrun\n\n" +
                       "How long can you help the traveler survive in a world where destinations become traps?";
        }
        
        // Split text into lines and draw with proper spacing
        let lines = storyText.split('\n');
        let y = canvasHeight * 0.25;
        let lineHeight = 24 * gameScaleFactor;
        
        for (let line of lines) {
            text(line, canvasWidth * 0.2, y, canvasWidth * 0.6);
            y += lineHeight;
        }
        
        // Navigation buttons
        textAlign(CENTER, CENTER);
        
        // Back button (except on first page)
        if (storyPage > 0) {
            fill(150, storyFadeIn);
            text("â—„ Previous", canvasWidth * 0.3, canvasHeight * 0.85);
        }
        
        // Next button (except on last page)
        if (storyPage < 2) {
            fill(150, storyFadeIn);
            text("Next â–º", canvasWidth * 0.7, canvasHeight * 0.85);
        }
        
        // Start game button on last page
        if (storyPage === 2) {
            fill(themeColors.spirits[0], themeColors.spirits[1], themeColors.spirits[2], storyFadeIn);
            text("Begin Journey", canvasWidth * 0.7, canvasHeight * 0.85);
        }
        
        // Return to main menu
        fill(150, storyFadeIn);
        text("Return to Menu", canvasWidth * 0.5, canvasHeight * 0.9);
        
        pop();
    }
    
    function drawGameOverScreen() {
        // Enhanced game over visual effect
        // Semi-transparent overlay with gradient
        noStroke();
        for (let i = 0; i < canvasHeight; i++) {
            let alpha = map(i, 0, canvasHeight, 150, 220);
            fill(0, 0, 0, alpha);
            rect(0, i, canvasWidth, 1);
        }
        
        push();
        textAlign(CENTER, CENTER);
        
        // Game Over text with enhanced styling
        textFont('Mali');
        textStyle(BOLD);
        
        // Text glow effect
        for (let i = 4; i > 0; i--) {
            let alpha = map(i, 4, 0, 40, 120);
            fill(255, 80, 60, alpha);
            textSize((54 + i*2) * gameScaleFactor);
            text("The Barriers Claim Another", canvasWidth / 2, canvasHeight * 0.3);
        }
        
        // Main text
        fill(255, 100, 80);
        textSize(54 * gameScaleFactor);
        text("The Barriers Claim Another", canvasWidth / 2, canvasHeight * 0.3);
        
        // Score display with enhanced styling
        textFont('Quicksand');
        textStyle(BOLD);
        
        // Score shadow
        fill(20, 20, 20, 150);
        textSize(36 * gameScaleFactor);
        text(`Your Journey: ${score.toFixed(1)} seconds`, canvasWidth / 2 + 2, canvasHeight * 0.42 + 2);
        
        // Score text
        fill(255, 250, 240);
        text(`Your Journey: ${score.toFixed(1)} seconds`, canvasWidth / 2, canvasHeight * 0.42);
        
        // High scores with improved styling
        textStyle(NORMAL);
        
        // Draw decorative line
        stroke(255, 200, 150, 100);
        strokeWeight(2);
        line(canvasWidth/2 - 150 * gameScaleFactor, canvasHeight * 0.48, 
             canvasWidth/2 + 150 * gameScaleFactor, canvasHeight * 0.48);
        
        // High score text
        noStroke();
        fill(255, 230, 200);
        textSize(26 * gameScaleFactor);
        text(`Session Best: ${sessionHighScore.toFixed(1)} seconds`, canvasWidth / 2, canvasHeight * 0.52);
        text(`All-time Best: ${lifetimeHighScore.toFixed(1)} seconds`, canvasWidth / 2, canvasHeight * 0.58);
        
        // Try again button with enhanced styling
        let buttonY = canvasHeight * 0.7;
        let buttonWidth = 280 * gameScaleFactor;
        let buttonHeight = 70 * gameScaleFactor;
        
        // Button glow
        for (let i = 3; i > 0; i--) {
            let alpha = map(i, 3, 0, 40, 100);
            fill(100, 180, 255, alpha);
            noStroke();
            rect(canvasWidth / 2, buttonY, buttonWidth + i*10, buttonHeight + i*10, 15);
        }
        
        // Main button
        fill(80, 120, 200);
        stroke(255, 180);
        strokeWeight(3);
        rect(canvasWidth / 2, buttonY, buttonWidth, buttonHeight, 12);
        
        // Button text
        fill(255);
        noStroke();
        textFont('Mali');
        textSize(32 * gameScaleFactor);
        text("Journey Again", canvasWidth / 2, buttonY);
        
        // Return to menu link with improved styling
        textFont('Quicksand');
        fill(220, 220, 230);
        textSize(24 * gameScaleFactor);
        text("Return to Menu", canvasWidth / 2, canvasHeight * 0.82);
        
        // Add subtle particles
        if (random() < 0.2) {
            let x = random(canvasWidth);
            let y = random(canvasHeight);
            let size = random(5, 15) * gameScaleFactor;
            
            fill(255, 255, 255, random(20, 80));
            noStroke();
            ellipse(x, y, size, size);
        }
        
        pop();
    }
    
    // Input handling functions
    
    function handleInput() {
        // Reset rotation speed
        playerRotationSpeed = 0;
        
        // Apply keyboard input
        if (keys.left) {
            if (holdStartTime.left !== null) {
                let holdDuration = millis() - holdStartTime.left;
                playerRotationSpeed = -calculateHoldSpeed(holdDuration);
            }
        }
        
        if (keys.right) {
            if (holdStartTime.right !== null) {
                let holdDuration = millis() - holdStartTime.right;
                playerRotationSpeed = calculateHoldSpeed(holdDuration);
            }
        }
        
        // Apply touch input
        if (touch.left) {
            if (holdStartTime.left !== null) {
                let holdDuration = millis() - holdStartTime.left;
                playerRotationSpeed = -calculateHoldSpeed(holdDuration);
            }
        }
        
        if (touch.right) {
            if (holdStartTime.right !== null) {
                let holdDuration = millis() - holdStartTime.right;
                playerRotationSpeed = calculateHoldSpeed(holdDuration);
            }
        }
    }
    
    function calculateHoldSpeed(holdDuration) {
        let speed = Config.holdBaseSpeed + 
                    pow(holdDuration * Config.holdAccelerationFactor, Config.holdExponent);
        return min(speed, Config.maxHoldSpeed);
    }
    
    function keyPressed() {
        if (gameState === 'playing') {
            if (keyCode === LEFT_ARROW) {
                keys.left = true;
                if (holdStartTime.left === null) {
                    playerTargetAngle -= Config.tapRotationAmount;
                    holdStartTime.left = millis();
                }
                return false;
            } else if (keyCode === RIGHT_ARROW) {
                keys.right = true;
                if (holdStartTime.right === null) {
                    playerTargetAngle += Config.tapRotationAmount;
                    holdStartTime.right = millis();
                }
                return false;
            }
        } else if (gameState === 'gameOver' || gameState === 'intro' || gameState === 'story') {
            if (keyCode === ENTER || keyCode === RETURN || keyCode === 32) { // Enter or Space
                startGame();
                return false;
            } else if (keyCode === ESCAPE) {
                gameState = 'intro';
                return false;
            }
        }
        return true;
    }
    
    function keyReleased() {
        if (keyCode === LEFT_ARROW) {
            keys.left = false;
            holdStartTime.left = null;
        } else if (keyCode === RIGHT_ARROW) {
            keys.right = false;
            holdStartTime.right = null;
        }
    }
    
    function touchStarted() {
        // Handle touch based on game state
        if (gameState === 'intro') {
            // Check if touch is on start button
            let buttonY = canvasHeight * 0.75;
            let buttonWidth = 200 * gameScaleFactor;
            let buttonHeight = 60 * gameScaleFactor;
            let buttonLeft = canvasWidth / 2 - buttonWidth / 2;
            let buttonRight = buttonLeft + buttonWidth;
            let buttonTop = buttonY - buttonHeight / 2;
            let buttonBottom = buttonTop + buttonHeight;
            
            if (mouseX >= buttonLeft && mouseX <= buttonRight &&
                mouseY >= buttonTop && mouseY <= buttonBottom) {
                startGame();
                return false;
            }
            
            // Check if touch is on "Read Story" button
            let storyButtonY = buttonY + buttonHeight + 20;
            let storyButtonTop = storyButtonY - 15;
            let storyButtonBottom = storyButtonY + 15;
            
            if (mouseX >= buttonLeft && mouseX <= buttonRight &&
                mouseY >= storyButtonTop && mouseY <= storyButtonBottom) {
                gameState = 'story';
                storyPage = 0;
                storyFadeIn = 0;
                return false;
            }
            
        } else if (gameState === 'story') {
            // Handle story navigation
            if (mouseY > canvasHeight * 0.8) {
                if (mouseX < canvasWidth * 0.4 && storyPage > 0) {
                    // Previous page
                    storyPage--;
                    storyFadeIn = 0;
                } else if (mouseX > canvasWidth * 0.6) {
                    if (storyPage < 2) {
                        // Next page
                        storyPage++;
                        storyFadeIn = 0;
                    } else {
                        // Start game from last page
                        startGame();
                    }
                } else if (mouseY > canvasHeight * 0.85) {
                    // Return to menu
                    gameState = 'intro';
                }
                return false;
            }
            
        } else if (gameState === 'playing') {
            // Game controls
            if (touches.length > 0) {
                let touchX = touches[0].x;
                
                if (touchX < canvasWidth / 2) {
                    // Left side touch
                    touch.left = true;
                    touch.right = false;
                    if (holdStartTime.left === null) {
                        playerTargetAngle -= Config.tapRotationAmount;
                        holdStartTime.left = millis();
                    }
                    holdStartTime.right = null;
                } else {
                    // Right side touch
                    touch.right = true;
                    touch.left = false;
                    if (holdStartTime.right === null) {
                        playerTargetAngle += Config.tapRotationAmount;
                        holdStartTime.right = millis();
                    }
                    holdStartTime.left = null;
                }
                return false;
            }
            
        } else if (gameState === 'gameOver') {
            // Check if touch is on "Try Again" button
            let buttonY = canvasHeight * 0.7;
            let buttonWidth = 220 * gameScaleFactor;
            let buttonHeight = 60 * gameScaleFactor;
            let buttonLeft = canvasWidth / 2 - buttonWidth / 2;
            let buttonRight = buttonLeft + buttonWidth;
            let buttonTop = buttonY - buttonHeight / 2;
            let buttonBottom = buttonTop + buttonHeight;
            
            if (mouseX >= buttonLeft && mouseX <= buttonRight &&
                mouseY >= buttonTop && mouseY <= buttonBottom) {
                startGame();
                return false;
            }
            
            // Check if touch is on "Return to Menu" link
            if (mouseY > canvasHeight * 0.78 && mouseY < canvasHeight * 0.82 &&
                mouseX > canvasWidth * 0.3 && mouseX < canvasWidth * 0.7) {
                gameState = 'intro';
                return false;
            }
        }
        
        return true;
    }
    
    function touchEnded() {
        touch.left = false;
        touch.right = false;
        holdStartTime.left = null;
        holdStartTime.right = null;
        return false;
    }
    
    function mousePressed() {
        // Handle mouse clicks similarly to touch
        return touchStarted();
    }
    
    function mouseReleased() {
        return touchEnded();
    }
    
    function startGame() {
        // Reset player state
        playerAngle = 0;
        playerTargetAngle = 0;
        playerRotationSpeed = 0;
        playerWalkFrame = 0;
        playerWalkSpeed = 0;
        playerFacingLeft = false;
        firstWallSpawned = false;
        
        // Initialize game elements
        initializeGame();
        
        // Change to playing state
        gameState = 'playing';
        startTime = millis();
        
        // Attempt to go fullscreen on mobile
        if (isMobile() && !document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.log("Fullscreen request failed: ", err);
            });
        }
        
        // Force landscape on mobile
        if (isMobile()) {
            screen.orientation.lock('landscape').catch(err => {
                console.log("Orientation lock failed: ", err);
            });
        }
    }
    
    function isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    
    function loadHighScores() {
        try {
            lifetimeHighScore = parseFloat(localStorage.getItem('cursedTravelerHighScore')) || 0;
        } catch (e) {
            lifetimeHighScore = 0;
        }
        sessionHighScore = 0;
    }
    
    function saveHighScores() {
        try {
            localStorage.setItem('cursedTravelerHighScore', lifetimeHighScore.toString());
        } catch (e) {
            console.log("Could not save high score to localStorage");
        }
    }
    
    function windowResized() {
        setupCanvas();
        gameScaleFactor = min(canvasWidth / 1920, canvasHeight / 1080);
        gameOffsetX = canvasWidth / 2;
        gameOffsetY = canvasHeight / 2;
    }
    
    // Prevent context menu on long press (mobile)
    window.oncontextmenu = function(event) {
        event.preventDefault();
        event.stopPropagation();
        return false;
    };
    </script>
</body>
</html>
