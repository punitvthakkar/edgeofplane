<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Edge of the Plane - Rewritten</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script> --> <!-- Sound commented out for simplicity for now -->
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Mali:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden; background-color: #000;
            display: flex; justify-content: center; align-items: center;
            touch-action: none; /* Crucial for mobile */
            font-family: 'Quicksand', 'Mali', sans-serif;
        }
        #game-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; box-shadow: 0 0 30px rgba(120, 180, 240, 0.3); }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- p5.js Canvas will be created here -->
    </div>

    <script>
    // --- Configuration ---
    const Config = {
        // Display & Scaling
        playerSizeBase: 35,
        playerOrbitFactor: 0.18, // % of minDimension
        powerupSizeBase: 25,
        barrierThicknessBase: 30,
        uiScaleBase: 1080, // Scale UI relative to this height

        // Controls (Requirement 3: Faster/Accelerated)
        holdBaseSpeed: 3.5,        // Start speed when holding
        holdAcceleration: 0.00025, // How quickly speed increases
        holdExponent: 1.7,         // Curve of acceleration
        maxHoldSpeed: 24,          // Max rotation speed (degrees/sec at 60fps)

        // Gameplay & Difficulty (Requirement 4: Random/Solvable Barriers)
        initialWallSpeedFactor: 0.0028, // Speed relative to minDimension/sec
        wallSpeedIncreaseFactor: 0.0000018,
        initialSpawnInterval: 130, // Frames between waves (at 60fps)
        firstWallDelay: 70,        // Frames before first wall
        spawnIntervalDecreaseFactor: 0.9978,
        minSpawnInterval: 28,
        initialGapSizeDeg: 80,
        gapSizeDecreaseFactor: 0.9993,
        minGapSizeDeg: 24,         // Minimum gap in degrees

        // Power-ups (Requirement 5: Specific Types)
        powerupSpawnChance: 0.0035, // Chance per frame if none active
        powerupMoveSpeedFactor: 0.0022, // Relative speed
        powerupTypes: {
            TRANSPARENCY: { id: 'TRANSPARENCY', duration: 5000, color: [255, 255, 255], weight: 5, symbol: 'ðŸ‘»' },
            BONUS_TIME: { id: 'BONUS_TIME', bonus: 7000, color: [255, 223, 0], weight: 3, symbol: '+7s' },
            FIREBALL: { id: 'FIREBALL', duration: 10000, color: [255, 100, 0], weight: 1, symbol: 'ðŸ”¥' }
        },

        // Visuals
        playerTrailLength: 10,
        playerTrailFadeSpeed: 20,
        maxParticles: 45,
        particleLifespan: 90,
        themeChangeScoreInterval: 45, // Seconds between theme changes

        // Story Hints
        storyPhrases: [
            "Find the path...", "Flow through...", "Spirits whisper...",
            "The walls deceive...", "React quickly...", "Embrace the void...",
            "Light finds a way...", "Don't stop..."
        ],
        hintInterval: 400, // Frames between hints
        hintDuration: 200, // Frames hint stays visible

        // Color Themes (Keep existing)
        colorThemes: [
            { name: "Forest Sanctuary", bg: [120, 180, 120], bgGradient: [100, 160, 100], player: [255, 250, 240], barriers: [60, 80, 40, 200], spirits: [240, 250, 200], particles: [220, 255, 200], powerup_bonus: [255, 223, 0], powerup_trans: [255, 255, 255], powerup_fire: [255, 100, 0] },
            { name: "Spirit Realm", bg: [70, 80, 140], bgGradient: [40, 50, 100], player: [250, 240, 255], barriers: [20, 30, 80, 200], spirits: [200, 240, 255], particles: [180, 220, 255], powerup_bonus: [255, 223, 0], powerup_trans: [255, 255, 255], powerup_fire: [255, 100, 0] },
            { name: "Floating Island", bg: [180, 210, 255], bgGradient: [130, 180, 230], player: [255, 255, 240], barriers: [100, 130, 180, 200], spirits: [255, 255, 200], particles: [255, 250, 220], powerup_bonus: [255, 223, 0], powerup_trans: [255, 255, 255], powerup_fire: [255, 100, 0] },
            { name: "Ancient Forest", bg: [80, 120, 80], bgGradient: [50, 70, 50], player: [240, 255, 240], barriers: [40, 60, 30, 200], spirits: [180, 255, 180], particles: [200, 255, 150], powerup_bonus: [255, 223, 0], powerup_trans: [255, 255, 255], powerup_fire: [255, 100, 0] },
            { name: "Sunset Journey", bg: [230, 180, 100], bgGradient: [180, 100, 80], player: [255, 255, 240], barriers: [160, 80, 40, 200], spirits: [255, 220, 150], particles: [255, 200, 120], powerup_bonus: [255, 223, 0], powerup_trans: [255, 255, 255], powerup_fire: [255, 100, 0] }
        ],
    };

    // --- Global State Variables ---
    let gameState = 'intro'; // intro, story, playing, gameOver
    let score = 0;
    let startTime = 0;
    let sessionHighScore = 0;
    let lifetimeHighScore = 0;
    let firstWallSpawned = false;

    // Player
    let playerAngle = 0;
    let playerRotationSpeed = 0; // Current speed (degrees per frame)
    let playerWalkFrame = 0;
    let playerFacingLeft = false;
    let playerTrail = [];
    let playerState = {
        isTransparent: false, transparencyEndTime: 0,
        isFireball: false, fireballEndTime: 0,
        visualAlpha: 255
    };

    // Gameplay Elements
    let barriers = [];
    let powerups = [];
    let particles = [];
    let floatingTexts = [];

    // Difficulty / Timing
    let currentDifficulty = {}; // Will be populated in setup/reset
    let lastFrameTime = 0; // For deltaTime calculation
    let timeScale = 1; // For potential slow-mo effects (future)

    // Display & Theme
    let canvasWidth, canvasHeight, minDimension, centerX, centerY;
    let gameScaleFactor, playerOrbitRadius; // Calculated dynamic values
    let currentThemeIndex = 0;
    let targetThemeIndex = 0;
    let themeBlendFactor = 1.0;
    let currentThemeColors = {}; // Holds the active (possibly blended) colors

    // Story / Hints
    let storyPage = 0;
    let storyFadeIn = 0;
    let currentStoryPhrase = "";
    let storyHintTimer = 0;
    let storyHintOpacity = 0;

    // Input Tracking
    let inputState = {
        left: false, right: false,
        holdStartLeft: null, holdStartRight: null
    };

    // --- Core P5 Functions ---

    function setup() {
        createCanvas(windowWidth, windowHeight);
        angleMode(DEGREES);
        rectMode(CENTER);
        textAlign(CENTER, CENTER);
        frameRate(60); // Attempt 60fps

        loadHighScores();
        updateDimensions();       // Initial calculation of sizes
        initializeElements();     // Create non-gameplay visuals
        resetGame();              // Set initial game state values
        currentThemeColors = getCurrentThemeColors(); // Initialize colors

        lastFrameTime = millis(); // Initialize for deltaTime
    }

    function draw() {
        let currentTime = millis();
        let dt = (currentTime - lastFrameTime) * timeScale; // Delta time in ms
        let dtFactor = dt / (1000 / 60); // Factor relative to ideal 60fps frame time
        lastFrameTime = currentTime;

        // --- Update Game State ---
        switch (gameState) {
            case 'playing':
                updatePlaying(dt, dtFactor);
                break;
            case 'intro':
            case 'story':
            case 'gameOver':
                // Minimal updates for animations if any
                updateParticles(dtFactor); // Update particles even on menus
                break;
        }

        // --- Update Visuals ---
        updateThemeBlending(dtFactor);
        currentThemeColors = getCurrentThemeColors(); // Get current/blended colors

        // --- Drawing ---
        let cameraAngle = -playerAngle; // Rotate world opposite to player

        // Draw background (always drawn)
        drawBackground(currentThemeColors); // Uses screen coords

        // Draw world elements (rotated)
        push();
        translate(centerX, centerY);
        rotate(cameraAngle);
        updateAndDrawSpiritGuides(dtFactor, currentThemeColors); // Example element update/draw
        updateAndDrawParticles(dtFactor); // Particles are in world space
        drawBarriers(currentThemeColors);
        drawPowerups(currentThemeColors);
        drawPlayerTrail(currentThemeColors); // Trail is part of the player's world presence
        drawPlayer(currentThemeColors); // Player is drawn at the correct world angle
        pop();

        // Draw UI / Overlays (not rotated)
        switch (gameState) {
            case 'playing':
                drawHUD(currentThemeColors);
                drawFloatingTexts(dtFactor);
                drawStoryHints(dtFactor, currentThemeColors);
                break;
            case 'intro':
                drawIntroScreen(currentThemeColors);
                break;
            case 'story':
                drawStoryScreen(currentThemeColors);
                break;
            case 'gameOver':
                // Draw frozen game world elements first (optional, could just draw overlay)
                push();
                translate(centerX, centerY);
                rotate(cameraAngle); // Use final camera angle
                // Redraw elements in their final state if desired
                updateAndDrawSpiritGuides(0, currentThemeColors); // 0 dtFactor = no update
                updateAndDrawParticles(0);
                drawBarriers(currentThemeColors);
                drawPowerups(currentThemeColors);
                drawPlayerTrail(currentThemeColors);
                drawPlayer(currentThemeColors);
                pop();
                // Then draw overlay
                drawGameOverScreen(currentThemeColors);
                drawFloatingTexts(dtFactor); // Show final score popups
                break;
        }
    }

    // --- Update Functions ---

    function updatePlaying(dt, dtFactor) {
        score = (millis() - startTime) / 1000;

        // Order is important: Input -> Player Update -> Collision Checks
        handleInput(dt); // Update playerRotationSpeed based on input
        updatePlayer(dt, dtFactor); // Update angle, state, animation
        updateBarriers(dtFactor);
        updatePowerups(dtFactor);
        updateFloatingTexts(dtFactor);

        checkCollisions(); // Check after movement
        checkPowerupCollisions(); // Check after movement

        updateDifficulty(); // Update based on current score
        spawnElements(); // Spawn barriers/powerups based on timers/chance
        checkForThemeChange(); // Check if theme should change
    }

    function handleInput(dt) {
        // Reset speed, then apply based on current input state
        playerRotationSpeed = 0;
        let now = millis(); // Use consistent time for hold duration calculation

        if (inputState.left) {
            if (inputState.holdStartLeft === null) inputState.holdStartLeft = now;
            let holdDuration = now - inputState.holdStartLeft;
            playerRotationSpeed = -calculateHoldSpeed(holdDuration);
        } else {
            inputState.holdStartLeft = null; // Clear timer when not held
        }

        if (inputState.right) {
            if (inputState.holdStartRight === null) inputState.holdStartRight = now;
            let holdDuration = now - inputState.holdStartRight;
             // If both left/right somehow active, right takes precedence
            playerRotationSpeed = calculateHoldSpeed(holdDuration);
        } else {
            inputState.holdStartRight = null; // Clear timer when not held
        }
        // Note: playerRotationSpeed is now degrees per *calculation*. We apply dtFactor later.
    }

    function calculateHoldSpeed(holdDuration) {
        let speedFactor = Config.holdBaseSpeed + pow(holdDuration * Config.holdAcceleration, Config.holdExponent);
        return min(speedFactor, Config.maxHoldSpeed); // Speed factor capped
    }

    function updatePlayer(dt, dtFactor) {
        // Apply rotation speed (scaled by deltaTime factor)
        playerAngle += playerRotationSpeed * dtFactor;
        playerAngle = (playerAngle % 360 + 360) % 360; // Keep angle in 0-360 range

        // Update Animation State (Requirement 2)
        if (abs(playerRotationSpeed) > 0.1) { // Animation threshold
            playerWalkFrame += abs(playerRotationSpeed * dtFactor) * 0.025; // Adjust animation speed factor
            if (playerWalkFrame > 4) playerWalkFrame %= 4; // Loop 0-4
            playerFacingLeft = playerRotationSpeed < 0;
        } else {
            playerWalkFrame = 0; // Idle frame
        }

        // Update Power-up Effects & Timers
        let now = millis();
        playerState.visualAlpha = 255; // Default alpha

        if (playerState.isTransparent) {
            if (now > playerState.transparencyEndTime) {
                playerState.isTransparent = false;
            } else {
                let timeLeft = playerState.transparencyEndTime - now;
                playerState.visualAlpha = (timeLeft < 1500 && (floor(now / 100) % 2 === 0)) ? 100 : 160; // Flicker when ending
            }
        }

        if (playerState.isFireball && now > playerState.fireballEndTime) {
            playerState.isFireball = false;
        }

        // Update Trail
        updatePlayerTrail(dtFactor);
    }

    function updatePlayerTrail(dtFactor) {
        let trailSize = Config.playerSizeBase * gameScaleFactor * 0.4;
        playerTrail.push({ angle: playerAngle, distance: playerOrbitRadius, alpha: 200, size: trailSize });

        while (playerTrail.length > Config.playerTrailLength) playerTrail.shift();

        for (let i = playerTrail.length - 1; i >= 0; i--) {
            let p = playerTrail[i];
            p.alpha -= Config.playerTrailFadeSpeed * dtFactor;
            p.size *= (1 - 0.06 * dtFactor); // Shrink based on dtFactor
            if (p.alpha <= 0 || p.size < 1) playerTrail.splice(i, 1);
        }
    }

    function updateDifficulty() {
        let elapsedSeconds = score;
        currentDifficulty.wallSpeed = (Config.initialWallSpeedFactor + elapsedSeconds * Config.wallSpeedIncreaseFactor) * minDimension;
        currentDifficulty.spawnInterval = max(Config.minSpawnInterval, Config.initialSpawnInterval * pow(Config.spawnIntervalDecreaseFactor, elapsedSeconds));
        currentDifficulty.gapSize = max(Config.minGapSizeDeg, Config.initialGapSizeDeg * pow(Config.gapSizeDecreaseFactor, elapsedSeconds));
        currentDifficulty.powerupMoveSpeed = Config.powerupMoveSpeedFactor * minDimension;
    }

    function updateBarriers(dtFactor) {
        for (let i = barriers.length - 1; i >= 0; i--) {
            let b = barriers[i];
            b.distance -= currentDifficulty.wallSpeed * dtFactor;
            if (b.alpha < 200) b.alpha = min(200, b.alpha + 8 * dtFactor);
            if (b.distance < -b.thickness * 2) { // Remove well after passing center
                barriers.splice(i, 1);
            }
        }
    }

    function updatePowerups(dtFactor) {
        for (let i = powerups.length - 1; i >= 0; i--) {
            let p = powerups[i];
            p.distance -= currentDifficulty.powerupMoveSpeed * dtFactor;
            p.rotation += 0.5 * dtFactor; // Gentle rotation
            if (p.alpha < 255) p.alpha = min(255, p.alpha + 5 * dtFactor);
            if (p.distance < -p.size) { // Remove after passing center
                powerups.splice(i, 1);
            }
        }
    }

    function updateFloatingTexts(dtFactor) {
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            let ft = floatingTexts[i];
            ft.y -= 0.8 * dtFactor; // Float up faster
            ft.alpha -= 4 * dtFactor; // Fade out faster
            if (ft.alpha <= 0) floatingTexts.splice(i, 1);
        }
    }

    function updateThemeBlending(dtFactor) {
        if (themeBlendFactor < 1) {
            themeBlendFactor += 0.015 * dtFactor; // Blend speed scaled by dtFactor
            if (themeBlendFactor >= 1) {
                themeBlendFactor = 1;
                currentThemeIndex = targetThemeIndex; // Finalize theme change
            }
        }
    }

     function updateAndDrawParticles(dtFactor) {
        noStroke();
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx * dtFactor;
            p.y += p.vy * dtFactor;
            p.lifespan -= dtFactor * (60 / (Config.particleLifespan || 90)); // Scale lifespan decrement
            p.alpha = 255 * (p.lifespan / 1.0); // Assuming lifespan is 0-1 now
             p.alpha = max(0, 255 * p.lifespan); // Lifespan is now 1 to 0
            p.size *= (1 - 0.02 * dtFactor); // Shrink

            if (p.lifespan <= 0 || p.size < 0.5) {
                particles.splice(i, 1);
            } else {
                 // Use particle color defined during creation
                 fill(p.color[0], p.color[1], p.color[2], p.alpha);
                ellipse(p.x, p.y, p.size, p.size);
            }
        }
    }

     function updateAndDrawSpiritGuides(dtFactor, colors) {
        for (let spirit of spiritGuides) {
            spirit.currentAngle = (spirit.currentAngle + spirit.speed * dtFactor) % 360;
             let distance = spirit.baseDistance * gameScaleFactor;
            distance += sin(frameCount * spirit.pulseSpeed + spirit.phaseOffset) * 8 * gameScaleFactor; // Scaled bobbing
            let size = spirit.baseSize * gameScaleFactor;

            let x = distance * cos(spirit.currentAngle);
            let y = distance * sin(spirit.currentAngle);

            // Draw (moved from separate draw function)
             push();
             translate(x, y);
             let glowSize = size * (1.5 + sin(frameCount * 2 + spirit.phaseOffset) * 0.2);
             let glowAlpha = 100 + sin(frameCount * 4 + spirit.phaseOffset) * 50;
             fill(colors.spirits[0], colors.spirits[1], colors.spirits[2], glowAlpha);
             noStroke();
             ellipse(0, 0, glowSize, glowSize);
             fill(255, 255, 255, 200); // Core
             ellipse(0, 0, size, size);
             pop();

            // Emit particles occasionally
             if (random() < 0.03 * dtFactor) { // Chance scaled by dtFactor
                 addParticle(x, y, random(-0.5, 0.5), random(-0.5, 0.5),
                             random(3, 8) * gameScaleFactor, colors.particles, 1.0); // Lifespan 1 to 0
             }
        }
    }


    // --- Spawning ---

    function spawnElements() {
        // Spawn Barriers
        if (!firstWallSpawned && frameCount > Config.firstWallDelay) {
            spawnBarrierWave();
            firstWallSpawned = true;
        } else if (firstWallSpawned && frameCount % floor(currentDifficulty.spawnInterval) === 0) {
            spawnBarrierWave();
        }

        // Spawn Powerups
        if (powerups.length === 0 && random() < Config.powerupSpawnChance) {
            spawnPowerup();
        }
    }

    function spawnBarrierWave() {
        let spawnDistance = max(width, height) * 0.75; // Spawn further out
        let gapCenterAngle = random(360);
        let halfGap = max(Config.minGapSizeDeg, currentDifficulty.gapSize) / 2; // Ensure min gap size
        let gapStart = (gapCenterAngle - halfGap + 360) % 360;
        let gapEnd = (gapCenterAngle + halfGap + 360) % 360;
        let barrierThickness = Config.barrierThicknessBase * gameScaleFactor;

        // Barrier 1: From gap end to gap start (potentially wrapping around 0/360)
        spawnBarrierSegment(gapEnd, gapStart, spawnDistance, barrierThickness);

        // Add hint particles
         addPassageHintParticles(gapCenterAngle, spawnDistance);
    }

     function spawnBarrierSegment(startAngle, endAngle, distance, thickness) {
         // This function handles the case where the segment might wrap around 360/0
         let currentAngle = startAngle;
         let endTarget = endAngle;

         // If endAngle is less than startAngle, it means we wrap around 360
         if (endTarget < currentAngle) {
             endTarget += 360;
         }

         // Define the segment properties
         let barrierData = {
             startAngle: startAngle % 360,
             endAngle: endAngle % 360, // Store original end angle
             distance: distance,
             thickness: thickness,
             alpha: 0 // Start transparent
         };

         // Check if the calculated end is actually different from the start after wrapping
         if (abs((endTarget - currentAngle + 360) % 360) > 0.1) { // Avoid zero-length barriers
              barriers.push(barrierData);
         }
    }


    function spawnPowerup() {
        let spawnDistance = max(width, height) * 0.7;
        let angle = random(360);
        let chosenType = chooseWeightedPowerup();

        powerups.push({
            type: chosenType.id,
            angle: angle,
            distance: spawnDistance,
            size: Config.powerupSizeBase * gameScaleFactor,
            color: chosenType.color,
            symbol: chosenType.symbol,
            duration: chosenType.duration,
            bonus: chosenType.bonus,
            alpha: 0,
            rotation: random(360)
        });
    }

    function chooseWeightedPowerup() {
        let totalWeight = Object.values(Config.powerupTypes).reduce((sum, type) => sum + type.weight, 0);
        let rand = random(totalWeight);
        let cumulativeWeight = 0;
        for (const type of Object.values(Config.powerupTypes)) {
            cumulativeWeight += type.weight;
            if (rand < cumulativeWeight) return type;
        }
        return Config.powerupTypes.TRANSPARENCY; // Fallback
    }

     function addParticle(x, y, vx, vy, size, color, lifespan = 1.0) { // lifespan 1 to 0
         if (particles.length >= Config.maxParticles) {
             particles.shift(); // Remove oldest
         }
         particles.push({ x, y, vx, vy, size, color: color || [255, 255, 255], lifespan });
     }

      function addPassageHintParticles(angle, distance) {
         let colors = getCurrentThemeColors(); // Get current colors
         let particleColor = colors.spirits || [200, 240, 255];
         let halfGap = currentDifficulty.gapSize / 2;
         for (let i = 0; i < 5; i++) {
             let offsetAngle = angle + random(-halfGap * 0.6, halfGap * 0.6); // Spread within gap center
             let offsetDist = distance + random(-10, 10);
             let x = offsetDist * cos(offsetAngle);
             let y = offsetDist * sin(offsetAngle);
             addParticle(x, y, random(-0.5, 0.5), random(-0.5, 0.5),
                         random(4, 9) * gameScaleFactor, particleColor, 0.8); // Shorter lifespan hints
         }
     }


    // --- Collision Detection ---

    function checkCollisions() {
        if (playerState.isTransparent) return; // Skip if transparent

        let playerHitRadius = Config.playerSizeBase * gameScaleFactor * 0.4; // Use a slightly smaller hitbox

        for (let i = barriers.length - 1; i >= 0; i--) {
            let b = barriers[i];
            if (!b || typeof b.distance !== 'number') continue; // Skip invalid barriers

            let distToBarrier = abs(b.distance - playerOrbitRadius);
            let collisionMargin = (b.thickness / 2) + playerHitRadius;

            if (distToBarrier < collisionMargin) {
                // Potential collision, check angle
                let pAngle = playerAngle;
                let start = b.startAngle;
                let end = b.endAngle;

                let collided = false;
                // Handle angle wrap-around check cleanly
                if (start <= end) { // Barrier does NOT wrap around 0/360
                    if (pAngle >= start && pAngle <= end) collided = true;
                } else { // Barrier DOES wrap around 0/360 (e.g., 350 to 10)
                    if (pAngle >= start || pAngle <= end) collided = true;
                }

                if (collided) {
                    if (playerState.isFireball) {
                        // Destroy barrier segment
                        createBarrierBreakEffect(b); // Visual effect
                        barriers.splice(i, 1);
                        // Potentially add sound effect here
                    } else {
                        gameOver();
                        return; // Exit collision check immediately
                    }
                }
            }
        }
    }

     function createBarrierBreakEffect(barrier) {
         let colors = getCurrentThemeColors();
         let breakAngle = playerAngle; // Angle where barrier broke
         let breakDist = barrier.distance;
         let particleColor = Config.powerupTypes.FIREBALL.color;
         for (let k = 0; k < 15; k++) {
             let angleOffset = random(-20, 20);
             let distOffset = random(-barrier.thickness, barrier.thickness);
             let x = (breakDist + distOffset) * cos(breakAngle + angleOffset);
             let y = (breakDist + distOffset) * sin(breakAngle + angleOffset);
             addParticle(x, y, random(-4, 4), random(-4, 4),
                         random(5, 15) * gameScaleFactor, particleColor, 1.0);
         }
     }

    function checkPowerupCollisions() {
        let playerHitRadius = Config.playerSizeBase * gameScaleFactor * 0.6; // Generous hitbox for powerups

        for (let i = powerups.length - 1; i >= 0; i--) {
            let p = powerups[i];
            let distToPowerup = abs(p.distance - playerOrbitRadius);
            let angleDiff = abs(p.angle - playerAngle);
            angleDiff = min(angleDiff, 360 - angleDiff); // Correct angle difference calculation

            // Collision check: distance + angle proximity
            // Angle proximity check is rough: is player angle within +/- angular size of powerup?
            let angularSize = degrees(atan(p.size / p.distance)) * 2; // Approx angular size
            if (distToPowerup < playerHitRadius + p.size / 2 && angleDiff < angularSize) {
                activatePowerup(p);
                powerups.splice(i, 1);
                return; // Process one pickup per frame
            }
        }
    }

    // --- Game State Changers ---

    function activatePowerup(powerup) {
        let now = millis();
        let x = centerX; // Position for text feedback (center screen)
        let y = centerY * 0.5; // Position slightly above center

        switch (powerup.type) {
            case Config.powerupTypes.TRANSPARENCY.id:
                playerState.isTransparent = true;
                playerState.transparencyEndTime = now + powerup.duration;
                playerState.isFireball = false; // Cancel fireball if active
                addFloatingText("Ghost!", x, y, powerup.color);
                break;
            case Config.powerupTypes.BONUS_TIME.id:
                startTime += powerup.bonus; // Add time by adjusting start
                addFloatingText(`+${powerup.bonus / 1000}s!`, x, y, powerup.color);
                break;
            case Config.powerupTypes.FIREBALL.id:
                playerState.isFireball = true;
                playerState.fireballEndTime = now + powerup.duration;
                playerState.isTransparent = false; // Cancel transparency
                addFloatingText("Inferno!", x, y, powerup.color);
                break;
        }
        // Particle effect on pickup
        createPickupEffect(powerup.color);
        // Add sound effect here potentially
    }

     function createPickupEffect(color) {
         let pX = playerOrbitRadius * cos(playerAngle);
         let pY = playerOrbitRadius * sin(playerAngle);
         for (let k = 0; k < 25; k++) {
             let angle = random(360);
             let speed = random(1, 4);
             addParticle(pX, pY, cos(angle) * speed, sin(angle) * speed,
                         random(4, 12) * gameScaleFactor, color, 1.0);
         }
     }

    function gameOver() {
        if (gameState === 'gameOver') return; // Prevent multiple calls
        gameState = 'gameOver';
        // Add sound effect?

        // Create explosion effect
        createPlayerExplosion();

        // Update High Scores
        if (score > sessionHighScore) sessionHighScore = score;
        if (score > lifetimeHighScore) {
            lifetimeHighScore = score;
            saveHighScores();
        }
    }

     function createPlayerExplosion() {
         let colors = getCurrentThemeColors();
         let x = playerOrbitRadius * cos(playerAngle);
         let y = playerOrbitRadius * sin(playerAngle);
         for (let i = 0; i < 50; i++) { // More particles for game over
              let angle = random(360);
              let speed = random(1, 6);
              let explosionColor = random() < 0.5 ? colors.player : colors.particles; // Mix colors
              addParticle( x, y, cos(angle) * speed, sin(angle) * speed, random(4, 18) * gameScaleFactor,
                          explosionColor, 1.0);
         }
     }


    function startGame() {
        resetGame(); // Reset all states
        initializeElements(); // Re-init visuals if needed (e.g., if resize occurred)
        gameState = 'playing';
        // Optional: Attempt fullscreen/orientation lock
        // tryEnterFullscreen();
        // tryLockOrientation();
    }

    function resetGame() {
        // Reset Core State
        score = 0;
        startTime = millis();
        firstWallSpawned = false;
        lastFrameTime = millis(); // Reset delta time base

        // Reset Player
        playerAngle = 0;
        playerRotationSpeed = 0;
        playerWalkFrame = 0;
        playerFacingLeft = false;
        playerTrail = [];
        playerState = { isTransparent: false, transparencyEndTime: 0, isFireball: false, fireballEndTime: 0, visualAlpha: 255 };

        // Reset Elements
        barriers = [];
        powerups = [];
        particles = []; // Clear existing particles
        floatingTexts = [];

        // Reset Difficulty
        currentDifficulty = {}; // Clear old values
        updateDifficulty(); // Set initial difficulty for score 0

        // Reset Theme
        targetThemeIndex = floor(random(Config.colorThemes.length));
        currentThemeIndex = targetThemeIndex;
        themeBlendFactor = 1.0;

         // Reset Input State
         inputState = { left: false, right: false, holdStartLeft: null, holdStartRight: null };
    }

    function initializeElements() {
        // Create elements that *don't* reset every game, like background stuff (if any)
        // Or re-create elements that depend heavily on initial screen dimensions if needed after resize
         createSpiritGuides(); // Example: recreate these based on new dimensions
         particles = []; // Ensure particles are clear on full init
    }


    // --- Drawing Functions ---

    function drawBackground(colors) {
        let gradStart = color(colors.bg[0], colors.bg[1], colors.bg[2]);
        let gradEnd = color(colors.bgGradient[0], colors.bgGradient[1], colors.bgGradient[2]);
        noStroke();
        for (let i = 0; i <= height; i++) {
            let inter = map(i, 0, height, 0, 1);
            stroke(lerpColor(gradStart, gradEnd, inter));
            line(0, i, width, i);
        }
        noStroke(); // Reset stroke
    }

    function drawPlayerTrail(colors) {
        noStroke();
        let trailColor = playerState.isFireball ? Config.powerupTypes.FIREBALL.color : colors.player;
        for (let p of playerTrail) {
             let trailX = p.distance * cos(p.angle);
             let trailY = p.distance * sin(p.angle);
             fill(trailColor[0], trailColor[1], trailColor[2], p.alpha * 0.7 * (playerState.visualAlpha / 255));
             ellipse(trailX, trailY, p.size, p.size);
        }
    }

    function drawPlayer(colors) {
        // Player origin is center, drawn at orbit radius and angle
        let x = playerOrbitRadius * cos(playerAngle);
        let y = playerOrbitRadius * sin(playerAngle);
        let size = Config.playerSizeBase * gameScaleFactor;

        push();
        translate(x, y);
        rotate(playerAngle + 90); // Orient sprite outward

        // --- Stick Figure Drawing (Requirement 2) ---
        let baseC = color(colors.player[0], colors.player[1], colors.player[2], playerState.visualAlpha);
        let stickC = color(40, 40, 40, playerState.visualAlpha * 0.8);
        let stickW = max(1.5, 2.5 * gameScaleFactor); // Ensure min weight

        // Fireball Effect Overlay
        if (playerState.isFireball) {
            let fireC = Config.powerupTypes.FIREBALL.color;
            baseC = color(fireC[0], fireC[1], fireC[2], playerState.visualAlpha);
            stickC = color(max(0, fireC[0] - 80), max(0, fireC[1] - 60), max(0, fireC[2] - 40), playerState.visualAlpha);

            // Pulsing Glow
            let glowSize = size * (1.6 + sin(millis() * 0.006) * 0.4); // Use ms for smoother animation
            let glowAlpha = 120 + sin(millis() * 0.007) * 60;
            noStroke();
            fill(fireC[0], fireC[1], fireC[2], glowAlpha * (playerState.visualAlpha / 255));
            ellipse(0, 0, glowSize, glowSize);
             // Emit particles when fireball
             if(random() < 0.2){
                 addParticle(x, y, random(-1,1), random(-1,1), random(2,5)*gameScaleFactor, fireC, 0.5);
             }
        } else {
             // Subtle standard glow
             let glowSize = size * 1.3;
             noStroke();
             fill(colors.player[0], colors.player[1], colors.player[2], 40 * (playerState.visualAlpha / 255));
             ellipse(0, 0, glowSize, glowSize);
        }

        // Actual Stick Figure
        scale(size / 50); // Base drawing on 50 unit height
        scale(playerFacingLeft ? -1 : 1, 1); // Mirroring

        stroke(stickC);
        strokeWeight(stickW / (size / 50)); // Adjust stroke weight based on scale
        strokeCap(ROUND);
        strokeJoin(ROUND);

        let walkPhase = playerWalkFrame * PI / 2;
        let legSwing = playerWalkFrame > 0 ? sin(walkPhase) * 10 : 0;
        let armSwing = playerWalkFrame > 0 ? cos(walkPhase) * 8 : 0;
        let headBob = playerWalkFrame > 0 ? (1 - cos(walkPhase * 2)) * 0.8 : 0; // Bob up and down

        // Legs
        line(0, 5, -5 - legSwing, 18); line(-5 - legSwing, 18, -4 - legSwing, 25);
        line(0, 5, 5 + legSwing, 18); line(5 + legSwing, 18, 4 + legSwing, 25);
        // Torso
        line(0, 5, 0, -10);
        // Arms
        line(0, -8, -6 - armSwing, 0); line(-6 - armSwing, 0, -8 - armSwing, 8);
        line(0, -8, 6 + armSwing, 0); line(6 + armSwing, 0, 8 + armSwing, 8);
        // Head
        fill(baseC);
        stroke(stickC);
        strokeWeight(stickW * 0.8 / (size / 50));
        ellipse(0, -16 + headBob, 12, 12);

        pop(); // Restore transformations
    }

     function drawBarriers(colors) {
        noFill();
        strokeCap(PROJECT);
        let barrierColor = color(colors.barriers[0], colors.barriers[1], colors.barriers[2]);
        let barrierAlpha = colors.barriers[3] || 200;

        for (let b of barriers) {
             if (b.distance < -b.thickness) continue;

             let innerRadius = max(0, b.distance - b.thickness / 2);
             let outerRadius = b.distance + b.thickness / 2;

             fill(red(barrierColor), green(barrierColor), blue(barrierColor), b.alpha * (barrierAlpha / 255) * 0.7); // Fill
             stroke(red(barrierColor), green(barrierColor), blue(barrierColor), b.alpha * (barrierAlpha / 255)); // Outline
             strokeWeight(max(1, 1.5 * gameScaleFactor));

             // Draw arc segment robustly
             // Handle wrap-around by potentially drawing two arcs or using angle logic
             let start = b.startAngle;
             let end = b.endAngle;

             beginShape();
             // Outer arc
             if (start <= end) { // No wrap
                 for (let a = start; a <= end; a += 4) vertex(outerRadius * cos(a), outerRadius * sin(a));
                 vertex(outerRadius * cos(end), outerRadius * sin(end));
             } else { // Wraps around
                  for (let a = start; a < 360; a += 4) vertex(outerRadius * cos(a), outerRadius * sin(a));
                  for (let a = 0; a <= end; a += 4) vertex(outerRadius * cos(a), outerRadius * sin(a));
                  vertex(outerRadius * cos(end), outerRadius * sin(end));
             }
             // Inner arc (reverse order)
              vertex(innerRadius * cos(end), innerRadius * sin(end));
              if (start <= end) { // No wrap
                  for (let a = end; a >= start; a -= 4) vertex(innerRadius * cos(a), innerRadius * sin(a));
                  vertex(innerRadius * cos(start), innerRadius * sin(start));
              } else { // Wraps around
                   for (let a = end; a > 0; a -= 4) vertex(innerRadius * cos(a), innerRadius * sin(a));
                   for (let a = 360; a >= start; a -= 4) vertex(innerRadius * cos(a), innerRadius * sin(a));
                    vertex(innerRadius * cos(start), innerRadius * sin(start));
              }

             endShape(CLOSE);
        }
        noFill();
    }

    function drawPowerups(colors) {
        // Uses world coordinates (drawn inside rotated push/pop)
        noFill();
        for (let p of powerups) {
             let x = p.distance * cos(p.angle);
             let y = p.distance * sin(p.angle);
             let size = p.size;

             push();
             translate(x, y);
             rotate(p.rotation);

             // Use specific powerup color
             let powerupColor = p.color || [255, 255, 255];

             // Outer Glow
             strokeWeight(size * 0.25);
             stroke(powerupColor[0], powerupColor[1], powerupColor[2], p.alpha * 0.4);
             ellipse(0, 0, size * 1.15, size * 1.15);

             // Main Ring
             strokeWeight(size * 0.18);
             stroke(powerupColor[0], powerupColor[1], powerupColor[2], p.alpha);
             ellipse(0, 0, size, size);
             pop();
        }
        noFill(); // Reset
    }


    function drawHUD(colors) {
        push();
        // Score
        textFont('Mali'); textStyle(BOLD);
        let scoreSize = max(18, 28 * gameScaleFactor);
        textSize(scoreSize);
        fill(20, 20, 20, 130);
        textAlign(RIGHT, TOP);
        text(`Score: ${score.toFixed(1)}`, width - 18, 18); // Use score var
        fill(255, 240, 220, 230);
        text(`Score: ${score.toFixed(1)}`, width - 20, 16);

        // Theme Name
        textFont('Quicksand'); textStyle(NORMAL);
        let themeNameSize = max(14, 20 * gameScaleFactor);
        textSize(themeNameSize);
        textAlign(LEFT, TOP);
        fill(20, 20, 20, 110);
        text(colors.name, 22, 18);
        fill(colors.spirits[0], colors.spirits[1], colors.spirits[2], 230);
        text(colors.name, 20, 16);

        // Power-up Timers
        textAlign(CENTER, TOP);
        let timerSize = max(14, 18 * gameScaleFactor);
        textSize(timerSize);
        let timerY = 20; // Start Y pos
        let timerLineHeight = timerSize * 1.3;

        if (playerState.isTransparent) {
            let timeLeft = (playerState.transparencyEndTime - millis()) / 1000;
            fill(Config.powerupTypes.TRANSPARENCY.color[0], Config.powerupTypes.TRANSPARENCY.color[1], Config.powerupTypes.TRANSPARENCY.color[2], 220);
            text(`Ghost: ${max(0, timeLeft).toFixed(1)}s`, width / 2, timerY);
            timerY += timerLineHeight;
        }
        if (playerState.isFireball) {
            let timeLeft = (playerState.fireballEndTime - millis()) / 1000;
            fill(Config.powerupTypes.FIREBALL.color[0], Config.powerupTypes.FIREBALL.color[1], Config.powerupTypes.FIREBALL.color[2], 220);
            text(`Inferno: ${max(0, timeLeft).toFixed(1)}s`, width / 2, timerY);
        }
        pop();
    }

     function drawFloatingTexts(dtFactor) {
        push();
        textAlign(CENTER, CENTER);
        textFont('Mali'); textStyle(BOLD);
        let textSizeBase = max(16, 24 * gameScaleFactor);
        for (let ft of floatingTexts) {
            textSize(textSizeBase * (1 + (255 - ft.alpha)/255 * 0.5) ); // Grow slightly as it fades
            fill(ft.color[0], ft.color[1], ft.color[2], ft.alpha);
            text(ft.text, ft.x, ft.y);
        }
        pop();
    }

     function drawStoryHints(dtFactor, colors) {
        storyHintTimer += dtFactor;
        if (storyHintTimer > Config.hintInterval) {
            currentStoryPhrase = random(Config.storyPhrases);
            storyHintOpacity = 0;
            storyHintTimer = 0; // Reset timer
        }

        if (storyHintTimer < Config.hintDuration) { // Fade in and stay visible
            storyHintOpacity = min(180, storyHintOpacity + 4 * dtFactor);
        } else if (storyHintTimer > Config.hintInterval - (Config.hintDuration / 2)) { // Fade out before next hint
            storyHintOpacity = max(0, storyHintOpacity - 5 * dtFactor);
        }


        if (storyHintOpacity > 5) {
            push();
            textFont('Mali');
            textAlign(CENTER, BOTTOM);
            let hintSize = max(16, 22 * gameScaleFactor);
            textSize(hintSize);
            fill(20, 20, 20, storyHintOpacity * 0.7);
            text(currentStoryPhrase, width / 2 + 1, height - 18); // Shadow
            fill(255, 255, 250, storyHintOpacity);
            text(currentStoryPhrase, width / 2, height - 20); // Text
            pop();
        }
    }

    // --- Screen Drawing Functions ---

    function drawIntroScreen(colors) {
        // Background is already drawn by main draw loop
        // Draw animated elements relative to center
        push();
        translate(centerX, centerY);
        noFill();
        for (let i = 0; i < 4; i++) {
            let sizeFactor = 0.2 + i * 0.15;
            let animSpeed = 0.0005 + i * 0.0001;
            let animOffset = i * PI;
            let size = minDimension * sizeFactor + sin(millis() * animSpeed + animOffset) * 15 * gameScaleFactor;
            stroke(colors.spirits[0], colors.spirits[1], colors.spirits[2], 100 - i * 15);
            strokeWeight(max(1, (2 + (4 - i) * 0.5) * gameScaleFactor));
            ellipse(0, 0, size, size);
        }
        pop();

        // Draw UI text & buttons (screen coords)
        push();
        textAlign(CENTER, CENTER);
        // Title
        textFont('Mali'); textStyle(BOLD);
        fill(255, 250, 245);
        textSize(max(36, 60 * gameScaleFactor));
        text("Edge of the Plane", width / 2, height * 0.3);
        // Subtitle
        textFont('Quicksand'); textStyle(NORMAL);
        textSize(max(20, 32 * gameScaleFactor));
        fill(colors.spirits[0], colors.spirits[1], colors.spirits[2], 230);
        text("An Endless Escape", width / 2, height * 0.4);
        // Instructions
        textSize(max(14, 20 * gameScaleFactor));
        fill(255, 250, 240, 220);
        text("Tap/Hold Left/Right or use Arrow Keys", width / 2, height * 0.55);
        text("Avoid walls, grab power-ups!", width / 2, height * 0.60);

        // Buttons
        drawButton("Begin Journey", width / 2, height * 0.72, 240, 70, colors);
        drawButton("Story", width / 2, height * 0.85, 180, 50, colors, 0.8);
        pop();
    }

    function drawStoryScreen(colors) {
        // Background drawn by main loop
        push(); // Isolate story drawing
        textAlign(CENTER, TOP);
        if (storyFadeIn < 255) storyFadeIn = min(255, storyFadeIn + 5);

        // Title
        textFont('Mali'); textStyle(BOLD);
        fill(255, 250, 220, storyFadeIn);
        textSize(max(28, 42 * gameScaleFactor));
        text("The Traveler's Curse", width / 2, height * 0.15);

        // Story Text
        textFont('Quicksand'); textStyle(NORMAL);
        fill(255, 245, 225, storyFadeIn);
        textSize(max(15, 20 * gameScaleFactor)); // Adaptive text size
        textAlign(LEFT, TOP);
        let storyText = [
            "Cursed by envy, the Traveler finds every path blocked. Walls rise from the void, turning destinations into traps. Lost, adrift, yet guided by faint whispers...",
            "Ancient spirits offer aid - fleeting lights in the closing darkness, revealing fragile gaps. They cannot break the curse, only illuminate the path. Survival demands focus, speed, and trust.",
            "Your turn. Guide the Traveler:\n\n â€¢ Flow through the gaps.\n â€¢ Harness spirit power (Orbs!).\n â€¢ Adapt to shifting realms.\n\nThe escape is endless. How far can you go?"
        ];
        let textX = width * 0.15, textY = height * 0.25;
        let textW = width * 0.7, textH = height * 0.5;
        text(storyText[storyPage], textX, textY, textW, textH);

        // Navigation Buttons
        let navY = height * 0.85;
        let backText = storyPage > 0 ? "â—„ Prev" : "";
        let nextText = storyPage < storyText.length - 1 ? "Next â–º" : "Start â–º";
        let menuText = "Menu";

        drawButton(backText, width * 0.3, navY, 150, 45, colors, 0.9, storyPage > 0);
        drawButton(nextText, width * 0.7, navY, 150, 45, colors, 0.9);
        drawButton(menuText, width / 2, height * 0.93, 150, 40, colors, 0.7);

        pop();
    }

    function drawGameOverScreen(colors) {
        // Background and frozen game world already drawn
        // Overlay
        fill(0, 0, 0, 190);
        rect(width / 2, height / 2, width, height);

        push();
        textAlign(CENTER, CENTER);
        // Game Over Text
        textFont('Mali'); textStyle(BOLD);
        fill(255, 100, 80);
        textSize(max(34, 54 * gameScaleFactor));
        text("The Void Claims You", width / 2, height * 0.3);
        // Score Display
        textFont('Quicksand'); textStyle(BOLD);
        fill(255, 250, 240);
        textSize(max(24, 36 * gameScaleFactor));
        text(`Survived: ${score.toFixed(1)} seconds`, width / 2, height * 0.42);
        // High Scores
        textStyle(NORMAL);
        fill(255, 230, 200);
        textSize(max(18, 26 * gameScaleFactor));
        text(`Session Best: ${sessionHighScore.toFixed(1)}s`, width / 2, height * 0.52);
        text(`All-time Best: ${lifetimeHighScore.toFixed(1)}s`, width / 2, height * 0.58);

        // Buttons
        drawButton("Journey Again", width / 2, height * 0.72, 260, 70, colors);
        drawButton("Menu", width / 2, height * 0.85, 180, 50, colors, 0.8);
        pop();
    }

     function drawButton(label, x, y, wBase, hBase, colors, scale = 1, enabled = true) {
        if (!label) return; // Don't draw if no label

        let btnW = wBase * gameScaleFactor * scale;
        let btnH = hBase * gameScaleFactor * scale;
        let textSize = max(14, 26 * gameScaleFactor * scale * 0.8); // Scaled text size

        let hover = enabled && isMouseOver(x, y, btnW, btnH);
        let btnColor = color(colors.barriers[0], colors.barriers[1], colors.barriers[2], enabled ? 220 : 100);
        let hoverColor = color(colors.spirits[0], colors.spirits[1], colors.spirits[2], enabled ? 240 : 120);
        let textColor = color(255, enabled ? 255 : 150);

        push();
        fill(hover ? hoverColor : btnColor);
        stroke(255, enabled ? 150 : 80);
        strokeWeight(max(1, 2 * gameScaleFactor));
        rect(x, y, btnW, btnH, 10 * gameScaleFactor * scale);

        fill(textColor);
        noStroke();
        textSize(textSize);
        textFont('Mali');
        text(label, x, y);
        pop();
    }


    // --- Input Handling ---

    function keyPressed() {
        // Block default browser behavior for arrow keys
        if (keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW || keyCode === UP_ARROW || keyCode === DOWN_ARROW || key === ' ') {
             if (gameState === 'playing' || gameState === 'intro' || gameState === 'gameOver' || gameState === 'story') {
                  // Handle game input if needed, or just prevent default
                  if (keyCode === LEFT_ARROW) inputState.left = true;
                  else if (keyCode === RIGHT_ARROW) inputState.right = true;
                  else if (key === ' ') handlePrimaryAction(); // Space bar action

                  return false;
             }
        }
         if (keyCode === ESCAPE) {
              handleEscapeAction();
              return false;
         }
        return true; // Allow other keys
    }

    function keyReleased() {
        if (keyCode === LEFT_ARROW) inputState.left = false;
        if (keyCode === RIGHT_ARROW) inputState.right = false;
        return false; // Prevent default behavior
    }

    function touchStarted() {
        if (!touches || touches.length === 0) return;
        let t = touches[0]; // Use first touch

        if (gameState === 'playing') {
            if (t.x < width / 2) inputState.left = true;
            else inputState.right = true;
        } else {
             // Handle button clicks for other states
             handleMouseOrTouchPress(t.x, t.y);
        }
        return false; // Prevent default touch actions (scroll/zoom)
    }

    function touchEnded() {
        // Stop movement regardless of which touch ended (simplest approach)
        inputState.left = false;
        inputState.right = false;
        inputState.holdStartLeft = null; // Reset hold timer on release
        inputState.holdStartRight = null;
        return false; // Prevent default
    }

    function mousePressed() {
        handleMouseOrTouchPress(mouseX, mouseY);
        return false; // Prevent default
    }

    function mouseReleased() {
        // For desktop, releasing mouse stops movement if it was initiated by mouse
         if(mouseX < width / 2) inputState.left = false;
         else inputState.right = false;
         inputState.holdStartLeft = null; // Reset hold timer on release
         inputState.holdStartRight = null;
    }

    function handleMouseOrTouchPress(x, y) {
         // Centralized button click logic
         if (gameState === 'intro') {
             if (isMouseOver(width / 2, height * 0.72, 240 * gameScaleFactor, 70 * gameScaleFactor, x, y)) startGame();
             else if (isMouseOver(width / 2, height * 0.85, 180 * gameScaleFactor * 0.8, 50 * gameScaleFactor * 0.8, x, y)) {
                 gameState = 'story'; storyPage = 0; storyFadeIn = 0;
             }
         } else if (gameState === 'story') {
             let navY = height * 0.85; let menuY = height * 0.93;
             if (storyPage > 0 && isMouseOver(width * 0.3, navY, 150 * gameScaleFactor * 0.9, 45 * gameScaleFactor * 0.9, x, y)) { storyPage--; storyFadeIn = 0; } // Prev
             else if (isMouseOver(width * 0.7, navY, 150 * gameScaleFactor * 0.9, 45 * gameScaleFactor * 0.9, x, y)) { // Next/Start
                 if (storyPage < 2) { storyPage++; storyFadeIn = 0; } else startGame();
             } else if (isMouseOver(width / 2, menuY, 150 * gameScaleFactor * 0.7, 40 * gameScaleFactor * 0.7, x, y)) { gameState = 'intro'; } // Menu
         } else if (gameState === 'gameOver') {
             if (isMouseOver(width / 2, height * 0.72, 260 * gameScaleFactor, 70 * gameScaleFactor, x, y)) startGame(); // Retry
             else if (isMouseOver(width / 2, height * 0.85, 180 * gameScaleFactor * 0.8, 50 * gameScaleFactor * 0.8, x, y)) { gameState = 'intro'; } // Menu
         } else if (gameState === 'playing') {
             // If clicking during play, treat like touch
             if (x < width / 2) inputState.left = true;
             else inputState.right = true;
         }
    }

    function handlePrimaryAction() { // e.g., Space Bar or Enter
        if (gameState === 'intro' || gameState === 'gameOver') {
             startGame(); // Main action is to start/retry
         } else if (gameState === 'story') {
              if (storyPage < 2) { storyPage++; storyFadeIn = 0; } // Next page
              else startGame(); // Start game from last page
         }
    }

    function handleEscapeAction() {
         if (gameState !== 'intro') {
              gameState = 'intro';
              storyFadeIn = 0; // Reset story fade if escaping from it
              // Potentially reset other things if escaping from 'playing'
         }
    }


    // --- Utilities ---

    function isMouseOver(rectX, rectY, rectW, rectH, checkX = mouseX, checkY = mouseY) {
        let left = rectX - rectW / 2;
        let right = rectX + rectW / 2;
        let top = rectY - rectH / 2;
        let bottom = rectY + rectH / 2;
        return checkX > left && checkX < right && checkY > top && checkY < bottom;
    }

    function loadHighScores() {
        try { lifetimeHighScore = parseFloat(localStorage.getItem('edgeOfPlaneHighScore')) || 0; }
        catch (e) { lifetimeHighScore = 0; }
        sessionHighScore = 0; // Reset session score on load
    }

    function saveHighScores() {
        try { localStorage.setItem('edgeOfPlaneHighScore', lifetimeHighScore.toString()); }
        catch (e) { console.error("Failed to save high score:", e); }
    }

    function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        updateDimensions();
        initializeElements(); // Re-initialize scaled elements
        // Redraw immediately to avoid artifacts
        if (typeof draw === 'function') { // Ensure draw exists
            redraw(); // Ask p5 to redraw canvas once
        }
    }

    function updateDimensions() {
        canvasWidth = width; canvasHeight = height;
        centerX = width / 2; centerY = height / 2;
        minDimension = min(width, height);
        gameScaleFactor = minDimension / Config.uiScaleBase;
        playerOrbitRadius = minDimension * Config.playerOrbitFactor;
    }

    function getCurrentThemeColors() {
        if (themeBlendFactor >= 1 || currentThemeIndex === targetThemeIndex) {
            return Config.colorThemes[targetThemeIndex];
        }
        // Perform blending (simplified - assumes structure matches)
        let currentC = Config.colorThemes[currentThemeIndex];
        let targetC = Config.colorThemes[targetThemeIndex];
        let blended = { name: targetC.name };
        try {
            for (let key in targetC) {
                if (key === 'name') continue;
                if (Array.isArray(targetC[key]) && currentC && Array.isArray(currentC[key]) && currentC[key].length === targetC[key].length) {
                    blended[key] = currentC[key].map((val, i) => {
                        if (typeof val === 'number' && typeof targetC[key][i] === 'number') {
                            return lerp(val, targetC[key][i], themeBlendFactor);
                        } return targetC[key][i]; // Fallback for non-numeric array elements
                    });
                } else { // Non-arrays or mismatched arrays, just switch
                     blended[key] = targetC[key];
                }
            }
        } catch (e) {
            console.error("Theme blending error", e); return targetC;
        }
        return blended;
    }

    function changeTheme() {
        currentThemeIndex = targetThemeIndex;
        let newIndex;
        if (Config.colorThemes.length <= 1) {
            newIndex = currentThemeIndex; // Cannot change if only one theme
        } else {
            do { newIndex = floor(random(Config.colorThemes.length)); }
            while (newIndex === currentThemeIndex);
        }
        targetThemeIndex = newIndex;
        themeBlendFactor = 0; // Start blending
    }

    function checkForThemeChange() {
        // Change theme based purely on score interval for simplicity
        if (floor(score / Config.themeChangeScoreInterval) > floor((score - (deltaTime/1000)) / Config.themeChangeScoreInterval)) {
             if (currentThemeIndex === targetThemeIndex) { // Only trigger if not already blending
                  changeTheme();
             }
        }
    }

    // --- Element Creation --- (Called during setup/reset)
     function createSpiritGuides() {
        spiritGuides = [];
         let minDist = minDimension * Config.spiritGuideDistanceFactorMin;
         let maxDist = minDimension * Config.spiritGuideDistanceFactorMax;
         for (let i = 0; i < Config.spiritGuidesCount; i++) {
             spiritGuides.push({
                 currentAngle: random(360), // Track current angle
                 baseDistance: random(minDist, maxDist),
                 baseSize: random(Config.spiritGuideSizeBase * 0.8, Config.spiritGuideSizeBase * 1.2),
                 speed: random(0.5, 1.5) * Config.spiritGuideOrbitSpeed,
                 pulseSpeed: random(1, 3),
                 phaseOffset: random(360)
             });
         }
     }
     // Add createForestElements, createCloudElements etc. if used, ensuring they use dynamic dimensions

    // Prevent context menu on long press (important for mobile)
    window.oncontextmenu = (event) => { event.preventDefault(); event.stopPropagation(); return false; };

    </script>
</body>
</html>
